<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://sandeshbhusal.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://sandeshbhusal.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-08-20T21:26:56+00:00</updated><id>https://sandeshbhusal.github.io/feed.xml</id><title type="html">Bhusal’s</title><entry><title type="html">Building smol Linux image for reproducible crashes</title><link href="https://sandeshbhusal.github.io/blog/2025/up-and-until-kernel-init/" rel="alternate" type="text/html" title="Building smol Linux image for reproducible crashes"/><published>2025-06-14T00:00:00+00:00</published><updated>2025-06-14T00:00:00+00:00</updated><id>https://sandeshbhusal.github.io/blog/2025/up-and-until-kernel-init</id><content type="html" xml:base="https://sandeshbhusal.github.io/blog/2025/up-and-until-kernel-init/"><![CDATA[ <p>The internet is filled with tutorials on building and debugging the Linux kernel. This isn’t one of them. This post details <em>my</em> personal workflow for building, running, and debugging the Linux kernel using QEMU, primarily for working with syzkaller bug reports.</p> <h3 id="getting-the-kernel-source">Getting the Kernel Source</h3> <p>When tackling a kernel bug, the first step is to get the correct version of the source code. A typical syzkaller stack trace will tell you exactly which version you need. For example, consider this report:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>------------[ cut here ]------------
ODEBUG: activate active (active state 1) object: ffff888025e8e118 object type: rcu_head hint: 0x0
WARNING: CPU: 1 PID: 5839 at lib/debugobjects.c:615 debug_print_object+0x17a/0x1f0 lib/debugobjects.c:612
Modules linked in:
CPU: 1 UID: 0 PID: 5839 Comm: strace-static-x Not tainted 6.14.0-syzkaller-01103-g2df0c02dab82 #0 PREEMPT(full)
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 02/12/2025
RIP: 0010:debug_print_object+0x17a/0x1f0 lib/debugobjects.c:612
Code: e8 8b a3 2d fd 4c 8b 0b 48 c7 c7 40 24 80 8c 48 8b 74 24 08 48 89 ea 44 89 e1 4d 89 f8 ff 34 24 e8 5b 2a 87 fc 48 83 c4 08 90
</code></pre></div></div> <p>The key information here is <code class="language-plaintext highlighter-rouge">6.14.0-syzkaller-01103-g2df0c02dab82</code>. This tells me the base version is <strong>6.14.0</strong>.</p> <p>Cloning the mainline kernel is straightforward:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/
</code></pre></div></div> <p>After cloning, I check out the specific commit or tag mentioned in the report to ensure my source tree matches the one where the bug occurred.</p> <hr/> <h3 id="configuring-the-build">Configuring the Build</h3> <p>My workflow is centered around QEMU, which simplifies the process of testing and debugging. I start by grabbing the <code class="language-plaintext highlighter-rouge">.config</code> file provided by syzkaller (see an <a href="https://syzkaller.appspot.com/text?tag=KernelConfig&amp;x=5f1762820c18874b">example here</a>) and copying it into the root of my kernel source directory.</p> <p>Next, I ensure the following configuration options are set correctly for a smooth debugging session with GDB:</p> <div class="language-make highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">CONFIG_DEBUG_INFO</span><span class="o">=</span>y
<span class="nv">CONFIG_DEBUG_INFO_DWARF5</span><span class="o">=</span>y
<span class="nv">CONFIG_DEBUG_INFO_REDUCED</span><span class="o">=</span>n
<span class="nv">CONFIG_RANDOMIZE_BASE</span><span class="o">=</span>n
</code></pre></div></div> <p>These settings are crucial:</p> <ul> <li><code class="language-plaintext highlighter-rouge">CONFIG_DEBUG_INFO=y</code> and <code class="language-plaintext highlighter-rouge">CONFIG_DEBUG_INFO_DWARF5=y</code> embed debugging information into the kernel image, allowing GDB to map executable code back to the source.</li> <li><code class="language-plaintext highlighter-rouge">CONFIG_RANDOMIZE_BASE=n</code> disables Kernel Address Space Layout Randomization (KASLR). With KASLR enabled, the kernel’s base address is randomized at boot, making it impossible for GDB to reliably set breakpoints. Disabling it ensures a predictable memory layout.</li> </ul> <p>Once the <code class="language-plaintext highlighter-rouge">.config</code> file is ready, I build the kernel:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make <span class="nt">-j</span><span class="si">$(</span><span class="nb">nproc</span><span class="si">)</span>
</code></pre></div></div> <hr/> <h3 id="creating-a-minimalist-ramdisk">Creating a Minimalist Ramdisk</h3> <p>For many debugging tasks, a full-blown root filesystem is overkill. I create a minimal initial ramdisk (<code class="language-plaintext highlighter-rouge">initramfs</code>) using <strong>BusyBox</strong>.</p> <ol> <li> <p><strong>Set up the directory structure.</strong></p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nb">mkdir</span> <span class="nt">-p</span> ramfs/<span class="o">{</span>bin,proc,dev,sys<span class="o">}</span>
</code></pre></div> </div> <p>A side note here is that all you really need is a directory for binaries. The kernel will create a directory for <code class="language-plaintext highlighter-rouge">/dev</code> when it boots, and my image still booted even when I did not have the <code class="language-plaintext highlighter-rouge">proc</code> and <code class="language-plaintext highlighter-rouge">sys</code> directories.</p> </li> <li> <p><strong>Add BusyBox and create symlinks.</strong> Copy the <code class="language-plaintext highlighter-rouge">busybox</code> binary into <code class="language-plaintext highlighter-rouge">ramfs/bin</code>. You can then create symbolic links for the essential commands you’ll need.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nb">cp</span> ~/wherever/busybox/is ./ramfs/bin/busybox <span class="o">&amp;&amp;</span> <span class="nb">chmod</span> +x ./ramfs/bin/busybox
 <span class="nb">cd </span>ramfs/bin
 <span class="nb">ln</span> <span class="nt">-s</span> busybox sh
 <span class="nb">ln</span> <span class="nt">-s</span> busybox clear
 <span class="nb">cd</span> ../..
</code></pre></div> </div> <p>To see a full list of available commands, just run the <code class="language-plaintext highlighter-rouge">busybox</code> binary with no arguments.</p> </li> <li> <p><strong>Create an <code class="language-plaintext highlighter-rouge">init</code> script.</strong> This script is the first process the kernel executes. Create a file named <code class="language-plaintext highlighter-rouge">init</code> in the <code class="language-plaintext highlighter-rouge">ramfs</code> directory with the following content:</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c">#!/bin/sh</span>
 <span class="c">#</span>
 <span class="c"># My minimal init script</span>
 <span class="c">#</span>
 mount <span class="nt">-t</span> proc none /proc
 mount <span class="nt">-t</span> sysfs none /sys

 clear
 <span class="nb">echo</span> <span class="s2">"Welcome to your custom kernel!"</span>
 <span class="nb">echo</span>

 /bin/sh
</code></pre></div> </div> <p>Make it executable:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nb">chmod</span> +x ramfs/init
</code></pre></div> </div> <p>Here, one thing to <em>absolutely not miss</em> would be the inital <a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">shebang</a>. If you miss that, then this init will not work. Which also means if you miss symlinking <code class="language-plaintext highlighter-rouge">/bin/busybox</code> to <code class="language-plaintext highlighter-rouge">/bin/sh</code>, it will not work.</p> </li> <li> <p><strong>Package the ramdisk.</strong> From the directory containing your <code class="language-plaintext highlighter-rouge">ramfs</code> folder, run the following command to create the <code class="language-plaintext highlighter-rouge">initramfs</code> image:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> find ramfs <span class="nt">-print0</span> | cpio <span class="nt">-0</span> <span class="nt">-o</span> <span class="nt">--format</span><span class="o">=</span>newc <span class="o">&gt;</span> initramfs.cpio
</code></pre></div> </div> <p>This command pipes a null-terminated list of files into <code class="language-plaintext highlighter-rouge">cpio</code>, which archives them into a compressed CPIO image. The <code class="language-plaintext highlighter-rouge">--format=newc</code> option is essential for the kernel to recognize it correctly.</p> </li> </ol> <hr/> <h3 id="booting-with-qemu">Booting with QEMU</h3> <p>With the kernel (<code class="language-plaintext highlighter-rouge">bzImage</code>) and the initial ramdisk (<code class="language-plaintext highlighter-rouge">initramfs.cpio</code>) ready, booting is a one-line command:</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>qemu-system-x86_64 <span class="se">\</span>
    <span class="nt">-kernel</span> <span class="nb">arch</span>/x86/boot/bzImage <span class="se">\</span>
    <span class="nt">-initrd</span> initramfs.cpio <span class="se">\</span>
    <span class="nt">-append</span> <span class="s2">"console=ttyS0"</span> <span class="se">\</span>
    <span class="nt">-m</span> 1G <span class="se">\</span>
    <span class="nt">-nographic</span> <span class="se">\</span>
    <span class="nt">-s</span> <span class="nt">-S</span>
</code></pre></div></div> <p>Let’s break down these options:</p> <ul> <li><code class="language-plaintext highlighter-rouge">-kernel</code>: Specifies the path to the compressed kernel image.</li> <li><code class="language-plaintext highlighter-rouge">-initrd</code>: Specifies the path to our initial ramdisk.</li> <li><code class="language-plaintext highlighter-rouge">-append "console=ttyS0"</code>: A kernel command-line parameter that directs all console output to the serial port, which is what we see in our terminal. <code class="language-plaintext highlighter-rouge">ttyS0</code> is the first serial port available in the device, which is generally a UART device.</li> <li><code class="language-plaintext highlighter-rouge">-m 1G</code>: Allocates 2GB of RAM to the virtual machine. This is essential.</li> <li><code class="language-plaintext highlighter-rouge">-nographic</code>: Prevents QEMU from opening a graphical window and instead redirects all I/O to the current terminal. I had to learn this one the hard way – after a certain point, the output is not shown if you look at the graphical window, right after <code class="language-plaintext highlighter-rouge">Booting the kernel</code>. So if you are stuck at that point, this will help.</li> <li><code class="language-plaintext highlighter-rouge">-s -S</code>: The <code class="language-plaintext highlighter-rouge">-S</code> part suspends the CPU at startup – which means qemu waits until we type <code class="language-plaintext highlighter-rouge">c</code> at the monitor. The <code class="language-plaintext highlighter-rouge">-s</code> part is shorthand for <code class="language-plaintext highlighter-rouge">-gdb tcp::1234</code>, which opens up a gdb server at port 1234 on the qemu host. We can connect to the server with the gdb client for debugging purposes.</li> </ul> <p>If everything is configured correctly, you’ll see your kernel boot messages, followed by the welcome message from your <code class="language-plaintext highlighter-rouge">init</code> script and a shell prompt.</p> <h3 id="attaching-with-gdb">Attaching with GDB</h3> <p>With QEMU waiting for a debugger connection, you can now attach GDB to the running kernel.</p> <p>First, launch GDB and point it to <code class="language-plaintext highlighter-rouge">vmlinux</code>, the uncompressed kernel executable that contains all the symbol and debugging information. It’s important to use <code class="language-plaintext highlighter-rouge">vmlinux</code> from the root of your kernel source tree, not the compressed <code class="language-plaintext highlighter-rouge">bzImage</code> (although that is what we booted up with qemu).</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gdb ./vmlinux
<span class="o">(</span>gdb<span class="o">)</span> target remote localhost:1234
</code></pre></div></div> <p>This command tells GDB to connect to a remote target. Sometimes, if you miss this step before setting breakpoints, gdb complains:</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> hbreak kernel_init
No hardware breakpoint support <span class="k">in </span>the target.
</code></pre></div></div> <p>So make sure that you set the <code class="language-plaintext highlighter-rouge">target remote</code> option before setting breakpoints.</p> <pre><code class="language-gdb">(gdb) add-auto-load-safe-path /path/to/your/linux/scripts/gdb/vmlinux-gdb.py
</code></pre> <p>The Linux kernel source comes with a collection of powerful helper scripts for GDB that understand kernel-specific data structures and states. This command adds the path to these scripts to GDB’s safe-path list, allowing it to load them automatically. These helpers provide commands like <code class="language-plaintext highlighter-rouge">lx-dmesg</code> to view the kernel log buffer or <code class="language-plaintext highlighter-rouge">lx-ps</code> to list processes within the debugged kernel, which are incredibly useful. And some other stuff starting with <a href="https://blogs.oracle.com/linux/post/live-kernel-debugging-2"><code class="language-plaintext highlighter-rouge">lx-</code></a>.</p> <pre><code class="language-gdb">(gdb) hbreak start_kernel
</code></pre> <p>This sets a hardware-assisted breakpoint at the <code class="language-plaintext highlighter-rouge">start_kernel</code> function, which is the official entry point for all architecture-independent kernel code. An <code class="language-plaintext highlighter-rouge">hbreak</code> (hardware breakpoint) is required. I could not break with a normal <code class="language-plaintext highlighter-rouge">break</code> breakpoint.</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> target remote localhost:1234
Remote debugging using localhost:1234
0x000000000000fff0 <span class="k">in</span> ?? <span class="o">()</span>
<span class="o">(</span>gdb<span class="o">)</span> <span class="nb">break </span>kernel_init
Breakpoint 1 at 0xffffffff82212bc0: file init/main.c, line 1465.
<span class="o">(</span>gdb<span class="o">)</span> c
Continuing.
Warning:
Cannot insert breakpoint 1.
Cannot access memory at address 0xffffffff82212bc0

Command aborted.
</code></pre></div></div> <p>Finally, <code class="language-plaintext highlighter-rouge">c</code> (or <code class="language-plaintext highlighter-rouge">continue</code>) tells GDB to resume the execution of the program. Since you started QEMU with the <code class="language-plaintext highlighter-rouge">-S</code> flag, the CPU was frozen. This command un-freezes it, and execution will proceed until it hits your breakpoint at <code class="language-plaintext highlighter-rouge">start_kernel</code>.</p> <pre><code class="language-gdb">(gdb) c
</code></pre> <p>You should see something like this on the screen (I’m using tmux):</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/gdb-kernel-init-480.webp 480w,/assets/img/gdb-kernel-init-800.webp 800w,/assets/img/gdb-kernel-init-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/gdb-kernel-init.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <blockquote> <p>Side fun, if you try to kill the console at this point with Ctrl+d on qemu, your kernel panics (as it should):</p> </blockquote> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>   12.788898] RDX: 00007f00aad9e030 RSI: 0000000000000000 RDI: 000000000000007f
<span class="o">[</span>   12.789624] RBP: 00007fff38c0dec8 R08: 0000000000000000 R09: 0000000000000000
<span class="o">[</span>   12.790350] R10: 0000000000000000 R11: 0000000000000246 R12: 00007fff38c0dec0
<span class="o">[</span>   12.791073] R13: 00007fff38c0deb8 R14: 0000000000000000 R15: 0000000000000000
<span class="o">[</span>   12.791805]  &lt;/TASK&gt;
<span class="o">[</span>   12.792438] Kernel Offset: disabled
<span class="o">[</span>   12.792810] <span class="nt">---</span><span class="o">[</span> end Kernel panic - not syncing: Attempted to <span class="nb">kill </span>init! <span class="nv">exitcode</span><span class="o">=</span>0x00007f00 <span class="o">]</span><span class="nt">---</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="linux"/><category term="os"/><summary type="html"><![CDATA[How I (sometimes) debug issues with reproducible kernel issues]]></summary></entry><entry><title type="html">Gossip Glomers - Efficient Broadcast</title><link href="https://sandeshbhusal.github.io/blog/2024/gossip-glomers/" rel="alternate" type="text/html" title="Gossip Glomers - Efficient Broadcast"/><published>2024-12-25T00:00:00+00:00</published><updated>2024-12-25T00:00:00+00:00</updated><id>https://sandeshbhusal.github.io/blog/2024/gossip-glomers</id><content type="html" xml:base="https://sandeshbhusal.github.io/blog/2024/gossip-glomers/"><![CDATA[<p><a href="https://fly.io/dist-sys/">Gossip Glomers</a> is a distributed systems challenge created by <a href="https://fly.io">fly.io</a>, where participants are expected to work around a simulating library called <code class="language-plaintext highlighter-rouge">maelstrom</code> that simulates failures and latencies in a distributed system. The library provided works with <code class="language-plaintext highlighter-rouge">go</code>, but being the rustacean that I am, I decided to rewrite the library in Rust, and implement solutions to the challenges. The <a href="">specifications</a> are publicly available (and well-documented) so it was a breeze to go through. In this post, I will only explain the solutions to the challenge upto the <em>efficient broadcast</em> challenge.</p> <h2 id="about-this-post">About this post.</h2> <p>This post is quite code-heavy as I expect the posts in this series to be. The challenge encompasses a lot of concepts in distributed systems, and frankly, squeezing all solutions into a single post will not make any sense. Instead, they will be spread out over posts in this series.</p> <h2 id="setting-up-the-project">Setting up the project</h2> <p>The ‘maelstrom’ binary can be downloaded and it unsurprisingly works right out of the box. For starters, I created the following project structure:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">.</span>
├── Cargo.lock
├── Cargo.toml
├── maelstrom
    ├── maelstrom
    └── ..
└── src
    ├── main.rs
    └── message.rs
</code></pre></div></div> <p>The <code class="language-plaintext highlighter-rouge">main.rs</code> file is responsible to run the entire application, and <code class="language-plaintext highlighter-rouge">message.rs</code> describes the types of messages we support.</p> <p>The <code class="language-plaintext highlighter-rouge">message.rs</code> file has the following contents:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">serde</span><span class="p">::{</span><span class="n">Deserialize</span><span class="p">,</span> <span class="n">Serialize</span><span class="p">};</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Serialize,</span> <span class="nd">Deserialize,</span> <span class="nd">Clone)]</span>
<span class="nd">#[serde(rename_all</span> <span class="nd">=</span> <span class="s">"snake_case"</span><span class="nd">)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Message</span> <span class="p">{</span>
    <span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="n">src</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="n">dest</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="n">body</span><span class="p">:</span> <span class="n">MessageBody</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Serialize,</span> <span class="nd">Deserialize,</span> <span class="nd">Clone)]</span>
<span class="nd">#[serde(tag</span> <span class="nd">=</span> <span class="s">"type"</span><span class="nd">,</span> <span class="nd">rename_all</span> <span class="nd">=</span> <span class="s">"snake_case"</span><span class="nd">)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">MessageBody</span> <span class="p">{</span>
    <span class="n">Echo</span> <span class="p">{</span>
        <span class="n">msg_id</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
        <span class="n">echo</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="n">EchoOk</span> <span class="p">{</span>
        <span class="n">msg_id</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
        <span class="n">in_reply_to</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
        <span class="n">echo</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="n">Init</span> <span class="p">{</span>
        <span class="n">msg_id</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
        <span class="n">node_id</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
        <span class="n">node_ids</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="n">InitOk</span> <span class="p">{</span>
        <span class="n">in_reply_to</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
    <span class="p">},</span>
<span class="p">}</span>
</code></pre></div></div> <p>One thing that I missed in the beginning was to return an <code class="language-plaintext highlighter-rouge">InitOk</code> message (which was outlined in the spec). Since the go library does that automatically, and we are not using go, we need to implement everything from scratch. Using serde makes this whole thing a breeze. The common fields go into <code class="language-plaintext highlighter-rouge">Message</code> struct, and fields specific to each type of message go to <code class="language-plaintext highlighter-rouge">MessageBody</code>. The body is named <code class="language-plaintext highlighter-rouge">type</code> in the incoming json message, and it seamlessly works with the following message for deserialization:</p> <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nl">"src"</span><span class="p">:</span><span class="w"> </span><span class="s2">"n0"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"dest"</span><span class="p">:</span><span class="w"> </span><span class="s2">"n1"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"body"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"echo_ok"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"msg_id"</span><span class="p">:</span><span class="w"> </span><span class="mi">123</span><span class="p">,</span><span class="w">
        </span><span class="nl">"echo"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Echo echo"</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div> <p>The next thing would be to implement methods to read/write from/to stdin/stdout.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">buffer</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">node</span><span class="p">:</span> <span class="n">Node</span> <span class="o">=</span> <span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">();</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="n">buffer</span><span class="nf">.clear</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="nf">stdin</span><span class="p">()</span><span class="nf">.read_line</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">buffer</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="k">if</span> <span class="n">len</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">message</span><span class="p">:</span> <span class="n">Message</span> <span class="o">=</span> <span class="k">match</span> <span class="nn">serde_json</span><span class="p">::</span><span class="nf">from_str</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">msg</span><span class="p">,</span>
            <span class="nf">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"Error parsing message: {}"</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">};</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">=</span> <span class="n">node</span><span class="nf">.handle_message</span><span class="p">(</span><span class="n">message</span><span class="p">)</span> <span class="p">{</span>
            <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"Error handling message: {}"</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div> <p>The node does not need to be concurrent - we process messages serially. The code keeps reading from stdin, creating a message (after deserializing), and passing the deserialized messages to the node. Next, the implementation for <code class="language-plaintext highlighter-rouge">Node</code> type.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Debug,</span> <span class="nd">Default,</span> <span class="nd">Clone)]</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="n">id</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">node_ids</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">current_msg_id</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">id</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">node_ids</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="n">Node</span> <span class="p">{</span>
            <span class="n">id</span><span class="p">,</span>
            <span class="n">node_ids</span><span class="p">,</span>
            <span class="n">current_msg_id</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">get_next_message_id</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">handle_echo</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">echo_in</span><span class="p">:</span> <span class="n">Message</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">handle_message</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="n">Message</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>The <code class="language-plaintext highlighter-rouge">Node</code> struct itself is very simple - it stores the node’s <code class="language-plaintext highlighter-rouge">id</code>, the <code class="language-plaintext highlighter-rouge">node_ids</code> of all nodes in the distributed system, and stores the current message id to use (no need to use atomic ints since we are just processing stuff in a single-thread). Next would be the implementation of each of these handlers. The <code class="language-plaintext highlighter-rouge">get_next_message_id</code> itself is very simple:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">get_next_message_id</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">current_id</span> <span class="o">=</span> <span class="k">self</span><span class="py">.current_msg_id</span><span class="p">;</span>
    <span class="k">self</span><span class="py">.current_msg_id</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">current_id</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="a-very-basic-echo">A very basic echo</h2> <p>In order to handle messages in the Node, we dispatch it to the <code class="language-plaintext highlighter-rouge">handle_message</code> function from our <code class="language-plaintext highlighter-rouge">main</code> function:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">handle_message</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="n">Message</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">match</span> <span class="n">message</span><span class="py">.body</span><span class="nf">.clone</span><span class="p">()</span> <span class="p">{</span>
        <span class="nn">MessageBody</span><span class="p">::</span><span class="n">Echo</span> <span class="p">{</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="k">self</span><span class="nf">.handle_echo</span><span class="p">(</span><span class="n">message</span><span class="p">),</span>
        <span class="nn">MessageBody</span><span class="p">::</span><span class="n">Init</span> <span class="p">{</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">msg_id</span><span class="p">,</span> <span class="n">node_ids</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="c1">// Initialize the node</span>
            <span class="k">self</span><span class="py">.id</span> <span class="o">=</span> <span class="n">node_id</span><span class="p">;</span>
            <span class="k">self</span><span class="py">.node_ids</span> <span class="o">=</span> <span class="n">node_ids</span><span class="p">;</span>

            <span class="c1">// Send init_ok response</span>
            <span class="k">let</span> <span class="n">reply_message</span> <span class="o">=</span> <span class="n">Message</span> <span class="p">{</span>
                <span class="n">src</span><span class="p">:</span> <span class="k">self</span><span class="py">.id</span><span class="nf">.clone</span><span class="p">(),</span>
                <span class="n">dest</span><span class="p">:</span> <span class="n">message</span><span class="nf">.clone</span><span class="p">()</span><span class="py">.src</span><span class="p">,</span>
                <span class="n">body</span><span class="p">:</span> <span class="nn">MessageBody</span><span class="p">::</span><span class="n">InitOk</span> <span class="p">{</span>
                    <span class="n">in_reply_to</span><span class="p">:</span> <span class="n">msg_id</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">};</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nn">serde_json</span><span class="p">::</span><span class="nf">to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reply_message</span><span class="p">)</span><span class="o">?</span><span class="p">);</span>
            <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nn">serde_json</span><span class="p">::</span><span class="nf">to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reply_message</span><span class="p">)</span><span class="o">?</span><span class="p">);</span>

            <span class="nf">Ok</span><span class="p">(())</span>
        <span class="p">}</span>
        <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"Unhandled message type"</span><span class="p">);</span>
            <span class="nf">Ok</span><span class="p">(())</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>The handle_message message is what brings it all together. We check the message type. If it’s the init message, we send a <code class="language-plaintext highlighter-rouge">ok</code> response for init and initialize our node. Otherwise, we dispatch the message to a relevant message handler. As we can see in the case of the <code class="language-plaintext highlighter-rouge">echo</code> message:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">handle_echo</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">echo_in</span><span class="p">:</span> <span class="n">Message</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nn">MessageBody</span><span class="p">::</span><span class="n">Echo</span> <span class="p">{</span> <span class="n">msg_id</span><span class="p">,</span> <span class="n">echo</span> <span class="p">}</span> <span class="o">=</span> <span class="n">echo_in</span><span class="py">.body</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">reply_message</span> <span class="o">=</span> <span class="n">Message</span> <span class="p">{</span>
            <span class="n">src</span><span class="p">:</span> <span class="k">self</span><span class="py">.id</span><span class="nf">.clone</span><span class="p">(),</span>
            <span class="n">dest</span><span class="p">:</span> <span class="n">echo_in</span><span class="py">.src</span><span class="p">,</span>
            <span class="n">body</span><span class="p">:</span> <span class="nn">MessageBody</span><span class="p">::</span><span class="n">EchoOk</span> <span class="p">{</span>
                <span class="n">msg_id</span><span class="p">:</span> <span class="k">self</span><span class="nf">.get_next_message_id</span><span class="p">(),</span>
                <span class="n">in_reply_to</span><span class="p">:</span> <span class="n">msg_id</span><span class="p">,</span>
                <span class="n">echo</span><span class="p">,</span>
            <span class="p">},</span>
        <span class="p">};</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nn">serde_json</span><span class="p">::</span><span class="nf">to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reply_message</span><span class="p">)</span><span class="o">?</span><span class="p">);</span>
        <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nn">serde_json</span><span class="p">::</span><span class="nf">to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reply_message</span><span class="p">)</span><span class="o">?</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div> <p>Even though the message type can never be anything other that <code class="language-plaintext highlighter-rouge">MessageBody::Echo</code>, we still use it to cast the message (I guess this would’ve been better in C++, since we have two vtable lookups, one in handle_message and another in <code class="language-plaintext highlighter-rouge">handle_echo</code>).</p> <p>Testing this with maelstrom library, we can see everything works:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>./maelstrom/maelstrom <span class="nb">test</span> <span class="nt">-w</span> <span class="nb">echo</span> <span class="nt">--bin</span> target/release/gossiprs <span class="se">\</span>
    <span class="nt">--node-count</span> 1 <span class="nt">--time-limit</span> 10

...
... bunch of output
...

Everything looks good! ヽ<span class="o">(</span>‘ー<span class="sb">`</span><span class="o">)</span>ノ
</code></pre></div></div> <h2 id="improving-message-handling">Improving message handling:</h2> <p>Since the first message is always the <code class="language-plaintext highlighter-rouge">init</code> message, we can check to see if that is actually the case, and only process messages after the first one (since we might miss a <code class="language-plaintext highlighter-rouge">init</code> message, and reach an invalid node state).</p> <div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gh">diff --git a/src/main.rs b/src/main.rs
index 8cb2685..434d943 100644
</span><span class="gd">--- a/src/main.rs
</span><span class="gi">+++ b/src/main.rs
</span><span class="p">@@ -6,6 +6,7 @@</span> use std::io::stdin;
 mod message;
 
 #[derive(Debug, Default, Clone)]
<span class="gi">+#[allow(unused)]
</span> struct Node {
     id: String,
     node_ids: Vec&lt;String&gt;,
<span class="p">@@ -44,27 +45,26 @@</span> impl Node {
         Ok(())
     }
 
<span class="gi">+    fn handle_init(&amp;mut self, msg_id: i32, src: String) -&gt; Result&lt;()&gt; {
+        // Send init_ok response
+        let reply_message = Message {
+            src: self.id.clone(),
+            dest: src,
+            body: MessageBody::InitOk {
+                in_reply_to: msg_id,
+            },
+        };
+        println!("{}", serde_json::to_string(&amp;reply_message)?);
+        eprintln!("{}", serde_json::to_string(&amp;reply_message)?);
+
+        Ok(())
+    }
+
</span>     fn handle_message(&amp;mut self, message: Message) -&gt; Result&lt;()&gt; {
         match message.body.clone() {
             MessageBody::Echo { .. } =&gt; self.handle_echo(message),
<span class="gd">-            MessageBody::Init { node_id, msg_id, node_ids } =&gt; {
-                // Initialize the node
-                self.id = node_id;
-                self.node_ids = node_ids;
-
-                // Send init_ok response
-                let reply_message = Message {
-                    src: self.id.clone(),
-                    dest: message.clone().src,
-                    body: MessageBody::InitOk {
-                        in_reply_to: msg_id,
-                    },
-                };
-                println!("{}", serde_json::to_string(&amp;reply_message)?);
-                eprintln!("{}", serde_json::to_string(&amp;reply_message)?);
</span><span class="gi">+            MessageBody::Init { msg_id, .. } =&gt; self.handle_init(msg_id, message.src.clone()),
</span> 
<span class="gd">-                Ok(())
-            }
</span>             _ =&gt; {
                 eprintln!("Unhandled message type");
                 Ok(())
<span class="p">@@ -76,26 +76,38 @@</span> impl Node {
 #[tokio::main]
 async fn main() -&gt; Result&lt;()&gt; {
     let mut buffer = String::new();
<span class="gd">-    let mut node: Node = Default::default();
</span> 
<span class="gd">-    loop {
-        buffer.clear();
-        let len = stdin().read_line(&amp;mut buffer)?;
-        if len == 0 {
-            break;
-        }
</span><span class="gi">+    stdin().read_line(&amp;mut buffer)?;
+    let message: Message = serde_json::from_str(&amp;buffer)?;
+
+    if let MessageBody::Init {
+        node_id, node_ids, ..
+    } = message.body
+    {
+        let mut node: Node = Node::new(node_id, node_ids);
+        node.handle_message(serde_json::from_str(&amp;buffer)?)?;
</span> 
<span class="gd">-        let message: Message = match serde_json::from_str(&amp;buffer) {
-            Ok(msg) =&gt; msg,
-            Err(e) =&gt; {
-                eprintln!("Error parsing message: {}", e);
-                continue;
</span><span class="gi">+        loop {
+            buffer.clear();
+            let len = stdin().read_line(&amp;mut buffer)?;
+            if len == 0 {
+                break;
</span>             }
<span class="gd">-        };
</span> 
<span class="gd">-        if let Err(e) = node.handle_message(message) {
-            eprintln!("Error handling message: {}", e);
</span><span class="gi">+            let message: Message = match serde_json::from_str(&amp;buffer) {
+                Ok(msg) =&gt; msg,
+                Err(e) =&gt; {
+                    eprintln!("Error parsing message: {}", e);
+                    continue;
+                }
+            };
+
+            if let Err(e) = node.handle_message(message) {
+                eprintln!("Error handling message: {}", e);
+            }
</span>         }
<span class="gi">+    } else {
+        panic!("Expected first messaage to be a init message");
</span>     }
 
     Ok(())
</code></pre></div></div> <h2 id="handling-unique-ids">Handling unique IDs</h2> <p>The next part of the challenge is to handle unique ID generation. For that, we will introduce the required message types to our <code class="language-plaintext highlighter-rouge">Message</code> struct, and store an internal counter in the Node. Also, we improve “responding” by sending out messages on <code class="language-plaintext highlighter-rouge">stdout</code> <em>and</em> logging our progress on <code class="language-plaintext highlighter-rouge">stderr</code>. The majority of the work is done in the <code class="language-plaintext highlighter-rouge">handle_generate</code> function as listed below:</p> <div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gh">diff --git a/src/main.rs b/src/main.rs
index 434d943..772c545 100644
</span><span class="gd">--- a/src/main.rs
</span><span class="gi">+++ b/src/main.rs
</span><span class="p">@@ -1,14 +1,18 @@</span>
 use anyhow::Result;
 use message::{Message, MessageBody};
 use serde_json;
<span class="gd">-use std::io::stdin;
</span><span class="gi">+use std::{
+    io::{stdin, Write},
+    sync::atomic::AtomicUsize,
+};
</span> 
 mod message;
 
<span class="gd">-#[derive(Debug, Default, Clone)]
</span><span class="gi">+#[derive(Debug)]
</span> #[allow(unused)]
 struct Node {
     id: String,
<span class="gi">+    counter: AtomicUsize,
</span>     node_ids: Vec&lt;String&gt;,
     current_msg_id: i32,
 }
<span class="p">@@ -16,6 +20,7 @@</span> struct Node {
 impl Node {
     fn new(id: String, node_ids: Vec&lt;String&gt;) -&gt; Self {
         Node {
<span class="gi">+            counter: AtomicUsize::new(0),
</span>             id,
             node_ids,
             current_msg_id: 0,
<span class="p">@@ -54,16 +59,45 @@</span> impl Node {
                 in_reply_to: msg_id,
             },
         };
<span class="gd">-        println!("{}", serde_json::to_string(&amp;reply_message)?);
-        eprintln!("{}", serde_json::to_string(&amp;reply_message)?);
</span> 
<span class="gd">-        Ok(())
</span><span class="gi">+        self.write_and_log_response(reply_message)
+    }
+
+    fn handle_generate(&amp;mut self, message: Message) -&gt; Result&lt;()&gt; {
+        // Generate a unique ID and send back to the receiver.
+        // To generate a unique ID, we will take the instant value in self,
+        // and just return the number of millis passed.
+
+        Ok(if let MessageBody::Generate { msg_id } = message.body {
+            let reply_message = Message {
+                src: self.id.clone(),
+                dest: message.src,
+                body: MessageBody::GenerateOk {
+                    id: format!(
+                        "{}-{}",
+                        self.id,
+                        self.counter
+                            .fetch_add(1, std::sync::atomic::Ordering::SeqCst)
+                    ),
+                    msg_id: self.get_next_message_id(),
+                    in_reply_to: msg_id,
+                },
+            };
+
+            self.write_and_log_response(reply_message)?
+        } else {
+            ()
+        })
</span>     }
 
     fn handle_message(&amp;mut self, message: Message) -&gt; Result&lt;()&gt; {
<span class="gi">+        let converted = serde_json::to_string(&amp;message)?;
+        eprintln!("Received request: {}", converted);
+
</span>         match message.body.clone() {
             MessageBody::Echo { .. } =&gt; self.handle_echo(message),
             MessageBody::Init { msg_id, .. } =&gt; self.handle_init(msg_id, message.src.clone()),
<span class="gi">+            MessageBody::Generate { .. } =&gt; self.handle_generate(message),
</span> 
             _ =&gt; {
                 eprintln!("Unhandled message type");
<span class="p">@@ -71,6 +105,13 @@</span> impl Node {
             }
         }
     }
<span class="gi">+
+    fn write_and_log_response(&amp;self, message: Message) -&gt; Result&lt;()&gt; {
+        let converted = serde_json::to_string(&amp;message)?;
+        println!("{}", converted);
+        eprint!("Responding: {}", converted);
+        Ok(std::io::stdout().flush()?)
+    }
</span> }
 
 #[tokio::main]
<span class="gh">diff --git a/src/message.rs b/src/message.rs
index 6c79550..01adec1 100644
</span><span class="gd">--- a/src/message.rs
</span><span class="gi">+++ b/src/message.rs
</span><span class="p">@@ -20,6 +20,7 @@</span> pub enum MessageBody {
         in_reply_to: i32,
         echo: String,
     },
<span class="gi">+
</span>     Init {
         msg_id: i32,
         node_id: String,
<span class="p">@@ -28,4 +29,14 @@</span> pub enum MessageBody {
     InitOk {
         in_reply_to: i32,
     },
<span class="gi">+
+    Generate {
+        msg_id: i32
+    },
+
+    GenerateOk {
+        id: String,
+        msg_id: i32,
+        in_reply_to: i32
+    },
</span> }
</code></pre></div></div> <h2 id="the-fun-begins">The fun begins!</h2> <p>Now the actual fun begins. We will implement methods to handle broadcast, and forward it to our peers.</p> <div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gh">diff --git a/src/main.rs b/src/main.rs
index 772c545..7b19426 100644
</span><span class="gd">--- a/src/main.rs
</span><span class="gi">+++ b/src/main.rs
</span><span class="p">@@ -2,6 +2,7 @@</span> use anyhow::Result;
 use message::{Message, MessageBody};
 use serde_json;
 use std::{
<span class="gi">+    collections::HashSet,
</span> };
<span class="p">@@ -14,6 +15,7 @@</span> struct Node {
     id: String,
<span class="gi">+    values: HashSet&lt;i32&gt;,
</span>     current_msg_id: i32,
 }
 
<span class="p">@@ -24,6 +26,7 @@</span> impl Node {
             id,
<span class="gi">+            values: HashSet::new(),
</span>         }
     }
<span class="err">
</span><span class="gi">+    fn handle_broadcast(&amp;mut self, message: Message) -&gt; Result&lt;()&gt; {
+        if let MessageBody::Broadcast {
+            msg_id,
+            message: value,
+        } = message.body
+        {
+            self.values.insert(value);
+            let reply = Message {
+                src: self.id.clone(),
+                dest: message.src,
+                body: MessageBody::BroadcastOk {
+                    in_reply_to: msg_id,
+                    msg_id: self.get_next_message_id(),
+                },
+            };
+
+            self.write_and_log_response(reply)
+        } else {
+            Ok(())
+        }
+    }
+
+    fn handle_read(&amp;mut self, message: Message) -&gt; Result&lt;()&gt; {
+        if let MessageBody::Read { msg_id } = message.body {
+            let messages: HashSet&lt;i32&gt; = self.values.clone();
+            let reply = Message {
+                src: self.id.clone(),
+                dest: message.src,
+                body: MessageBody::ReadOk {
+                    messages,
+                    in_reply_to: msg_id,
+                },
+            };
+
+            self.write_and_log_response(reply)
+        } else {
+            Ok(())
+        }
+    }
+
+    fn handle_topology(&amp;mut self, message: Message) -&gt; Result&lt;()&gt; {
+        if let MessageBody::Topology { msg_id, .. } = message.body {
+            let reply = Message {
+                src: self.id.clone(),
+                dest: message.src,
+                body: MessageBody::TopologyOk {
+                    in_reply_to: msg_id,
+                },
+            };
+
+            self.write_and_log_response(reply)
+        } else {
+            Ok(())
+        }
+    }
+
</span>     fn handle_message(&amp;mut self, message: Message) -&gt; Result&lt;()&gt; {
         let converted = serde_json::to_string(&amp;message)?;
         eprintln!("Received request: {}", converted);
<span class="p">@@ -98,6 +157,9 @@</span> impl Node {
             MessageBody::Echo { .. } =&gt; self.handle_echo(message),
<span class="gi">+            MessageBody::Broadcast { .. } =&gt; self.handle_broadcast(message),
+            MessageBody::Read { .. } =&gt; self.handle_read(message),
+            MessageBody::Topology { .. } =&gt; self.handle_topology(message),
</span> 
             _ =&gt; {
                 eprintln!("Unhandled message type");
<span class="gh">diff --git a/src/message.rs b/src/message.rs
index 01adec1..7dd52b7 100644
</span><span class="gd">--- a/src/message.rs
</span><span class="gi">+++ b/src/message.rs
</span><span class="p">@@ -1,3 +1,5 @@</span>
<span class="gi">+use std::collections::{HashMap, HashSet};
+
</span> #[derive(Debug, Serialize, Deserialize, Clone)]
<span class="p">@@ -39,4 +41,32 @@</span> pub enum MessageBody {
<span class="gi">+    Broadcast {
+        msg_id: i32,
+        message: i32
+    },
+
+    BroadcastOk {
+        in_reply_to: i32,
+        msg_id: i32
+    },
+
+    Read {
+        msg_id: i32,
+    },
+
+    ReadOk {
+        messages: HashSet&lt;i32&gt;,
+        in_reply_to: i32
+    },
+
+    Topology {
+        msg_id: i32,
+        topology: HashMap&lt;String, Vec&lt;String&gt;&gt;
+    },
+
+    TopologyOk {
+        in_reply_to: i32
+    }
</span> }
</code></pre></div></div> <p>For this, we need to implement handlers for <code class="language-plaintext highlighter-rouge">read</code>, <code class="language-plaintext highlighter-rouge">topology</code>, and <code class="language-plaintext highlighter-rouge">broadcast</code> messages as listed in the outline. The logic itself is super simple; we store all the IDs we’ve seen in a <code class="language-plaintext highlighter-rouge">HashSet</code>, and return the hashset when <code class="language-plaintext highlighter-rouge">read</code> is invoked on our node.</p> <h2 id="talking-to-other-nodes">Talking to other nodes</h2> <p>The next patch will implement a way to talk to other nodes, whatever is connected to ours.</p> <div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gh">diff --git a/src/main.rs b/src/main.rs
index 7b19426..0f955b8 100644
</span><span class="gd">--- a/src/main.rs
</span><span class="gi">+++ b/src/main.rs
</span><span class="p">@@ -17,6 +17,8 @@</span> struct Node {
     node_ids: Vec&lt;String&gt;,
     values: HashSet&lt;i32&gt;,
     current_msg_id: i32,
<span class="gi">+    neighbors: Vec&lt;String&gt;,
+    downstream: Vec&lt;String&gt;,
</span> }
 
 impl Node {
<span class="p">@@ -27,6 +29,8 @@</span> impl Node {
             node_ids,
             current_msg_id: 0,
             values: HashSet::new(),
<span class="gi">+            neighbors: Vec::new(),
+            downstream: Vec::new(),
</span>         }
     }
 
<span class="p">@@ -99,7 +103,7 @@</span> impl Node {
             message: value,
         } = message.body
         {
<span class="gd">-            self.values.insert(value);
</span><span class="gi">+            // First, respond that I got this value.
</span>             let reply = Message {
                 src: self.id.clone(),
                 dest: message.src,
<span class="p">@@ -109,7 +113,65 @@</span> impl Node {
                 },
             };
 
<span class="gd">-            self.write_and_log_response(reply)
</span><span class="gi">+            self.write_and_log_response(reply)?;
+
+            let i_have_this = self.values.contains(&amp;value);
+            if !i_have_this {
+                self.values.insert(value);
+
+                // Tell my friends about this too!. Write Gossip messages.
+                let neighbors = self.neighbors.clone();
+                for neighbor in neighbors {
+                    let new_msg_id = self.get_next_message_id();
+
+                    let gossip = Message {
+                        src: self.id.clone(),
+                        dest: neighbor.clone(),
+                        body: MessageBody::Gossip {
+                            msg_id: new_msg_id,
+                            gossip_value: value,
+                        },
+                    };
+
+                    self.write_and_log_response(gossip)?;
+                }
+            }
+
+            Ok(())
+        } else {
+            Ok(())
+        }
+    }
+
+    fn handle_gossip(&amp;mut self, message: Message) -&gt; Result&lt;()&gt; {
+        if let MessageBody::Gossip {
+            gossip_value: value,
+            ..
+        } = message.body
+        {
+            let i_have_this = self.values.contains(&amp;value);
+            if !i_have_this {
+                self.values.insert(value);
+
+                // Tell my friends about this too!. Write Gossip messages.
+                let neighbors = self.neighbors.clone();
+                for neighbor in neighbors {
+                    let new_msg_id = self.get_next_message_id();
+
+                    let gossip = Message {
+                        src: self.id.clone(),
+                        dest: neighbor.clone(),
+                        body: MessageBody::Gossip {
+                            msg_id: new_msg_id,
+                            gossip_value: value,
+                        },
+                    };
+
+                    self.write_and_log_response(gossip)?;
+                }
+            }
+
+            Ok(())
</span>         } else {
             Ok(())
         }
<span class="p">@@ -134,7 +196,21 @@</span> impl Node {
     }
 
     fn handle_topology(&amp;mut self, message: Message) -&gt; Result&lt;()&gt; {
<span class="gd">-        if let MessageBody::Topology { msg_id, .. } = message.body {
</span><span class="gi">+        if let MessageBody::Topology {
+            msg_id,
+            topology: graph,
+        } = message.body
+        {
+            self.neighbors = graph
+                .get(&amp;self.id)
+                .expect("No neighbors defined for me? Empty??")
+                .clone();
+
+            // Something fancy. Do some graph computation to find downstream nodes? Nah.
+            // Maybe in 3.d.
+
+            self.downstream.extend(self.neighbors.clone());
+
</span>             let reply = Message {
                 src: self.id.clone(),
                 dest: message.src,
<span class="p">@@ -160,6 +236,7 @@</span> impl Node {
             MessageBody::Broadcast { .. } =&gt; self.handle_broadcast(message),
             MessageBody::Read { .. } =&gt; self.handle_read(message),
             MessageBody::Topology { .. } =&gt; self.handle_topology(message),
<span class="gi">+            MessageBody::Gossip { .. } =&gt; self.handle_gossip(message),
</span> 
             _ =&gt; {
                 eprintln!("Unhandled message type");
<span class="gh">diff --git a/src/message.rs b/src/message.rs
index 7dd52b7..1748ee8 100644
</span><span class="gd">--- a/src/message.rs
</span><span class="gi">+++ b/src/message.rs
</span><span class="p">@@ -68,5 +68,12 @@</span> pub enum MessageBody {
 
     TopologyOk {
         in_reply_to: i32
<span class="gd">-    }
</span><span class="gi">+    },
+
+    // Custom message types:
+
+    Gossip {
+        msg_id: i32,
+        gossip_value: i32
+    },
</span> }
</code></pre></div></div> <p>The logic is simple:</p> <ul> <li>We <code class="language-plaintext highlighter-rouge">Gossip</code> our message to our peers when we receive a gossip message. Before doing that, we acknowledge the gossip.</li> <li>The <code class="language-plaintext highlighter-rouge">GossipAck</code> message is sent to the sender to make sure they don’t re-send the gossip again (this comes in a later part).</li> </ul> <p>If we do not respond before updating our state, we will fall into an infinite loop where we forward the message, receive it, and keep forwarding it. So, we first ack the message, and <em>then</em> forward it to the neighbors.</p> <h2 id="sending-message-with-retries">Sending message with Retries</h2> <p>The current method implements ways to send message, but we do not retry if it fails. Since we don’t have the privilege of using <code class="language-plaintext highlighter-rouge">SyncRPC</code> that is in the go library, we need to implement our own. The go library uses <code class="language-plaintext highlighter-rouge">Context</code> with <code class="language-plaintext highlighter-rouge">Cancel</code>, and something similar that can be implemented in Rust is a <code class="language-plaintext highlighter-rouge">oneshot_channel</code>. For every message we expect to receive a reply to, we store a <code class="language-plaintext highlighter-rouge">oneshot</code> channel, which is keyed on the message id. If we receive any message whose <code class="language-plaintext highlighter-rouge">in_reply_to</code> field has that particular message id, we pop the channel, and cancel our timeout.</p> <div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gh">diff --git a/src/main.rs b/src/main.rs
index 0f955b8..b61487b 100644
</span><span class="gd">--- a/src/main.rs
</span><span class="gi">+++ b/src/main.rs
</span><span class="p">@@ -2,10 +2,12 @@</span> use anyhow::Result;
 use message::{Message, MessageBody};
 use serde_json;
 use std::{
<span class="gd">-    collections::HashSet,
</span><span class="gi">+    collections::{HashMap, HashSet},
</span>     io::{stdin, Write},
     sync::atomic::AtomicUsize,
<span class="gi">+    time::Duration,
</span> };
<span class="gi">+use tokio::{runtime::Runtime, time};
</span> 
 mod message;
 
<span class="p">@@ -13,24 +15,28 @@</span> mod message;
 #[allow(unused)]
 struct Node {
     id: String,
<span class="gi">+    runtime: Runtime,
</span>     counter: AtomicUsize,
     node_ids: Vec&lt;String&gt;,
     values: HashSet&lt;i32&gt;,
     current_msg_id: i32,
     neighbors: Vec&lt;String&gt;,
     downstream: Vec&lt;String&gt;,
<span class="gi">+    ack_channels: HashMap&lt;i32, tokio::sync::oneshot::Sender&lt;i32&gt;&gt;,
</span> }
 
 impl Node {
     fn new(id: String, node_ids: Vec&lt;String&gt;) -&gt; Self {
         Node {
             counter: AtomicUsize::new(0),
<span class="gi">+            runtime: Runtime::new().unwrap(),
</span>             id,
             node_ids,
             current_msg_id: 0,
             values: HashSet::new(),
             neighbors: Vec::new(),
             downstream: Vec::new(),
<span class="gi">+            ack_channels: HashMap::new(),
</span>         }
     }
 
<span class="p">@@ -51,8 +57,8 @@</span> impl Node {
                     echo,
                 },
             };
<span class="gd">-            println!("{}", serde_json::to_string(&amp;reply_message)?);
-            eprintln!("{}", serde_json::to_string(&amp;reply_message)?);
</span><span class="gi">+
+            self.write_and_log_response(reply_message)?;
</span>         }
         Ok(())
     }
<span class="p">@@ -238,6 +244,19 @@</span> impl Node {
             MessageBody::Topology { .. } =&gt; self.handle_topology(message),
             MessageBody::Gossip { .. } =&gt; self.handle_gossip(message),
 
<span class="gi">+            MessageBody::GossipAck {
+                in_reply_to,
+                msg_id,
+            } =&gt; {
+                // Check that we have the channel to send the ack.
+                if let Some(sender) = self.ack_channels.remove(&amp;in_reply_to) {
+                    Ok(sender.send(msg_id).unwrap())
+                } else {
+                    eprintln!("No channel found to send ack");
+                    Ok(())
+                }
+            }
+
</span>             _ =&gt; {
                 eprintln!("Unhandled message type");
                 Ok(())
<span class="p">@@ -245,11 +264,39 @@</span> impl Node {
         }
     }
 
<span class="gd">-    fn write_and_log_response(&amp;self, message: Message) -&gt; Result&lt;()&gt; {
-        let converted = serde_json::to_string(&amp;message)?;
-        println!("{}", converted);
-        eprint!("Responding: {}", converted);
-        Ok(std::io::stdout().flush()?)
</span><span class="gi">+    fn write_and_log_response(&amp;mut self, message: Message) -&gt; Result&lt;()&gt; {
+        if let MessageBody::Gossip { msg_id, .. } = &amp;message.body {
+            let (sender, mut receiver) = tokio::sync::oneshot::channel::&lt;i32&gt;();
+            self.ack_channels.insert(*msg_id, sender);
+
+            // Try to send the message to the receiver, wait for a certain time, and send the message
+            // again if we do not get the response back. Do all this within a tokio runtime.
+            let fut = async move {
+                let converted = serde_json::to_string(&amp;message).unwrap();
+                println!("{}", converted);
+                let mut ticker = time::interval(Duration::from_millis(100));
+
+                loop {
+                    tokio::select! {
+                        _ = ticker.tick() =&gt; {
+                            // Resend the message; we have no acks yet.
+                            println!("{}", converted.clone());
+                        }
+                        _ = &amp;mut receiver =&gt; {
+                            // We got an ack! Break the loop.
+                            break
+                        }
+                    }
+                }
+            };
+
+            self.runtime.spawn(fut);
+            Ok(())
+        } else {
+            println!("{}", serde_json::to_string(&amp;message)?);
+            eprint!("Responding: {}", serde_json::to_string(&amp;message)?);
+            Ok(std::io::stdout().flush()?)
+        }
</span>     }
 }
 
<span class="gh">diff --git a/src/message.rs b/src/message.rs
index 1748ee8..d331470 100644
</span><span class="gd">--- a/src/message.rs
</span><span class="gi">+++ b/src/message.rs
</span><span class="p">@@ -76,4 +76,9 @@</span> pub enum MessageBody {
         msg_id: i32,
         gossip_value: i32
     },
<span class="gi">+
+    GossipAck {
+        in_reply_to: i32,
+        msg_id: i32
+    }
</span> }
</code></pre></div></div> <p>In order to implement this, we create a <code class="language-plaintext highlighter-rouge">Tokio</code> runtime, and push futures that are polling the stdin, looking for messages we have replies to, or waiting on a timer, which fires every 100ms. Either the message reply arrives, or the timer expires, when we resend the message. Since we are only looking for replies (confirmation) to the Gossip messages, we match the message type on message send. The future is created only if the message type matches Gossip message. The modification to handling gossip is simple enough:</p> <div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gh">diff --git a/src/main.rs b/src/main.rs
index b61487b..ab1b253 100644
</span><span class="gd">--- a/src/main.rs
</span><span class="gi">+++ b/src/main.rs
</span><span class="p">@@ -152,9 +152,21 @@</span> impl Node {
     fn handle_gossip(&amp;mut self, message: Message) -&gt; Result&lt;()&gt; {
         if let MessageBody::Gossip {
             gossip_value: value,
<span class="gd">-            ..
</span><span class="gi">+            msg_id
</span>         } = message.body
         {
<span class="gi">+            // First, respond that I got this value.
+            let reply = Message {
+                src: self.id.clone(),
+                dest: message.src,
+                body: MessageBody::GossipAck {
+                    in_reply_to: msg_id,
+                    msg_id: self.get_next_message_id(),
+                },
+            };
+
+            self.write_and_log_response(reply)?;
+
</span>             let i_have_this = self.values.contains(&amp;value);
             if !i_have_this {
                 self.values.insert(value);
</code></pre></div></div> <h2 id="latency-constraints">Latency constraints.</h2> <p>This is the part I had the most fun with while completing the first part of this challenge. You are supposed to send messages with 400ms latency medians (600ms max latency). The constraints are:</p> <ul> <li>30 message-per-op</li> <li>400ms median latency</li> <li>600ms max latency</li> </ul> <p>given that every message has 100ms latency within the system. This means, we need to optimize our graph in some way. In a overkill fashion, I decided to write a genetic algorithm to generate the graph.</p> <h3 id="genetic-algorithm-for-graph-generation">Genetic Algorithm for graph generation.</h3> <p>The graph will be encoded in the following way:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">random</span>
<span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Self</span>
<span class="kn">import</span> <span class="n">networkx</span> <span class="k">as</span> <span class="n">nx</span>
<span class="kn">import</span> <span class="n">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="n">NUM_NODES_FIXED</span> <span class="o">=</span> <span class="mi">25</span>
<span class="n">POPULATION_SIZE</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">MAX_ITERATIONS</span>  <span class="o">=</span> <span class="mi">500</span>
<span class="n">MAX_PERMISSIBLE_PATH_LENGTH</span> <span class="o">=</span> <span class="mi">6</span>

<span class="k">class</span> <span class="nc">Graph</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">num_nodes</span> <span class="o">=</span> <span class="mi">25</span><span class="p">,</span> <span class="n">max_permissible_path_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">self</span><span class="p">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_nodes</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">max_permissible_path_length</span> <span class="o">=</span> <span class="n">max_permissible_path_length</span>
        <span class="n">self</span><span class="p">.</span><span class="n">edges</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">from_vertex</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">to_vertex</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="nf">if </span><span class="p">(</span><span class="n">from_vertex</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">vertices</span> <span class="ow">or</span> <span class="n">to_vertex</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">vertices</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">self</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">from_vertex</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">edges</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">from_vertex</span><span class="p">,</span> <span class="p">[])</span> <span class="ow">or</span> <span class="p">[]</span>
        <span class="n">self</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">to_vertex</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">edges</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">to_vertex</span><span class="p">,</span> <span class="p">[])</span> <span class="ow">or</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">to_vertex</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">from_vertex</span><span class="p">]:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">from_vertex</span><span class="p">].</span><span class="nf">append</span><span class="p">(</span><span class="n">to_vertex</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">to_vertex</span><span class="p">].</span><span class="nf">append</span><span class="p">(</span><span class="n">from_vertex</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_distances</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">from_vertex</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nf">set</span><span class="p">()</span>

        <span class="n">queue</span> <span class="o">=</span> <span class="p">[(</span><span class="n">from_vertex</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
        <span class="n">distances</span><span class="p">[</span><span class="n">from_vertex</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">visited</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">from_vertex</span><span class="p">)</span>

        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">first</span><span class="p">,</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">edges</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="p">[])</span>
            <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                    <span class="n">visited</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">neighbor</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="n">distances</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">=</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">distances</span>

    <span class="k">def</span> <span class="nf">get_nodes_count</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">vertices</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">check_average_propagation_cost</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="n">score</span> <span class="o">=</span> <span class="mi">0</span>
         
        <span class="n">disconnected_nodes</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">nodes_with_maxpath_violations</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">max_edges</span> <span class="o">=</span> <span class="nf">max </span><span class="p">([</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">edges</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="p">[]))</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">vertices</span> <span class="p">])</span>
        <span class="n">total_edges</span> <span class="o">=</span> <span class="nf">sum</span><span class="p">([</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">edges</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="p">[]))</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">vertices</span> <span class="p">])</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">vertices</span><span class="p">:</span>
            <span class="n">distances</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">get_distances</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">disconnected_nodes</span> <span class="o">+=</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">vertices</span><span class="p">)</span> <span class="o">-</span> <span class="nf">len</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span> <span class="c1"># Calculate the number of nodes unreachable from this
</span>            <span class="n">nodes_with_maxpath_violations</span> <span class="o">+=</span> <span class="nf">len</span><span class="p">([</span><span class="n">tonode</span> <span class="k">for</span> <span class="n">tonode</span> <span class="ow">in</span> <span class="n">distances</span> <span class="k">if</span> <span class="n">distances</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">tonode</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">MAX_PERMISSIBLE_PATH_LENGTH</span> <span class="p">])</span>

        <span class="n">score</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">100000</span> <span class="o">*</span> <span class="n">disconnected_nodes</span> <span class="c1"># All nodes MUST be connected
</span>        <span class="n">score</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">100000</span> <span class="o">*</span> <span class="n">nodes_with_maxpath_violations</span>
        <span class="n">score</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">2000</span> <span class="o">*</span> <span class="n">max_edges</span>
        <span class="n">score</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">250</span> <span class="o">*</span> <span class="n">total_edges</span>

        <span class="k">return</span> <span class="n">score</span>
</code></pre></div></div> <p>The functions are pretty self-explanatory:</p> <ul> <li><code class="language-plaintext highlighter-rouge">get_nodes_count</code> returns the number of nodes in the graph.</li> <li><code class="language-plaintext highlighter-rouge">check_average_propagation_cost</code> returns the score of the graph. The score is calculated as: <ul> <li>100000 * disconnected_nodes: All nodes must be connected.</li> <li>100000 * nodes_with_maxpath_violations: No node should have a path length greater than 6.</li> <li>2000 * max_edges: The maximum number of edges in the graph.</li> <li>250 * total_edges: The total number of edges in the graph.</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">get_distances</code> returns the distances from a node to all other nodes in the graph.</li> <li><code class="language-plaintext highlighter-rouge">add_edge</code> adds an edge between two nodes. The edges are bidirectional.</li> <li><code class="language-plaintext highlighter-rouge">__init__</code> initializes the graph.</li> </ul> <p>Using this, and implementing a simple genetic algorithm, we land with a graph that looks like this:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">"n17"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n19"</span><span class="p">,</span> <span class="s">"n0"</span><span class="p">],</span>
<span class="s">"n19"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n17"</span><span class="p">,</span> <span class="s">"n14"</span><span class="p">],</span>
<span class="s">"n10"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n2"</span><span class="p">,</span> <span class="s">"n22"</span><span class="p">,</span> <span class="s">"n20"</span><span class="p">],</span>
<span class="s">"n2"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n10"</span><span class="p">,</span> <span class="s">"n13"</span><span class="p">,</span> <span class="s">"n11"</span><span class="p">],</span>
<span class="s">"n13"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n2"</span><span class="p">,</span> <span class="s">"n15"</span><span class="p">],</span>
<span class="s">"n7"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n14"</span><span class="p">,</span> <span class="s">"n3"</span><span class="p">],</span>
<span class="s">"n14"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n7"</span><span class="p">,</span> <span class="s">"n19"</span><span class="p">,</span> <span class="s">"n12"</span><span class="p">],</span>
<span class="s">"n24"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n22"</span><span class="p">,</span> <span class="s">"n1"</span><span class="p">,</span> <span class="s">"n23"</span><span class="p">],</span>
<span class="s">"n22"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n24"</span><span class="p">,</span> <span class="s">"n10"</span><span class="p">,</span> <span class="s">"n8"</span><span class="p">],</span>
<span class="s">"n18"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n5"</span><span class="p">,</span> <span class="s">"n15"</span><span class="p">],</span>
<span class="s">"n5"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n18"</span><span class="p">,</span> <span class="s">"n0"</span><span class="p">,</span> <span class="s">"n3"</span><span class="p">],</span>
<span class="s">"n0"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n4"</span><span class="p">,</span> <span class="s">"n17"</span><span class="p">,</span> <span class="s">"n5"</span><span class="p">],</span>
<span class="s">"n4"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n0"</span><span class="p">,</span> <span class="s">"n8"</span><span class="p">],</span>
<span class="s">"n1"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n24"</span><span class="p">,</span> <span class="s">"n6"</span><span class="p">,</span> <span class="s">"n11"</span><span class="p">],</span>
<span class="s">"n23"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n24"</span><span class="p">,</span> <span class="s">"n6"</span><span class="p">,</span> <span class="s">"n16"</span><span class="p">],</span>
<span class="s">"n21"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n20"</span><span class="p">,</span> <span class="s">"n12"</span><span class="p">,</span> <span class="s">"n9"</span><span class="p">],</span>
<span class="s">"n20"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n21"</span><span class="p">,</span> <span class="s">"n9"</span><span class="p">,</span> <span class="s">"n10"</span><span class="p">],</span>
<span class="s">"n15"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n13"</span><span class="p">,</span> <span class="s">"n12"</span><span class="p">,</span> <span class="s">"n18"</span><span class="p">],</span>
<span class="s">"n6"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n1"</span><span class="p">,</span> <span class="s">"n23"</span><span class="p">,</span> <span class="s">"n3"</span><span class="p">],</span>
<span class="s">"n12"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n21"</span><span class="p">,</span> <span class="s">"n14"</span><span class="p">,</span> <span class="s">"n15"</span><span class="p">],</span>
<span class="s">"n9"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n21"</span><span class="p">,</span> <span class="s">"n20"</span><span class="p">],</span>
<span class="s">"n11"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n2"</span><span class="p">,</span> <span class="s">"n1"</span><span class="p">],</span>
<span class="s">"n3"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n7"</span><span class="p">,</span> <span class="s">"n6"</span><span class="p">,</span> <span class="s">"n5"</span><span class="p">],</span>
<span class="s">"n8"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n4"</span><span class="p">,</span> <span class="s">"n16"</span><span class="p">,</span> <span class="s">"n22"</span><span class="p">],</span>
<span class="s">"n16"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n23"</span><span class="p">,</span> <span class="s">"n8"</span><span class="p">],</span>

</code></pre></div></div> <p>Instead of using the given topology, this is the topology we can use. With this, we get the following results on median:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>latencies:
0.5<span class="o">=</span>434, 1:599

msg-per-op:
29
</code></pre></div></div> <p>The genetic algorithm is as follows:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Chromosome</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">self</span><span class="p">.</span><span class="n">graph</span> <span class="o">=</span> <span class="nc">Graph</span><span class="p">(</span><span class="n">num_nodes</span><span class="o">=</span><span class="n">NUM_NODES_FIXED</span><span class="p">,</span> <span class="n">max_permissible_path_length</span><span class="o">=</span><span class="n">MAX_PERMISSIBLE_PATH_LENGTH</span><span class="p">)</span>
        <span class="c1"># Initialize some random connections
</span>        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">50</span><span class="p">)):</span>
            <span class="n">from_node</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">NUM_NODES_FIXED</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">to_node</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">NUM_NODES_FIXED</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">from_node</span> <span class="o">!=</span> <span class="n">to_node</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">add_edge</span><span class="p">(</span><span class="n">from_node</span><span class="p">,</span> <span class="n">to_node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">mutate</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
        <span class="sh">"""</span><span class="s">
        Mutation strategies:
        1. Add a random edge
        2. Remove a random edge
        3. Rewire an existing edge
        </span><span class="sh">"""</span>
        <span class="n">mutation_type</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">choice</span><span class="p">([</span><span class="sh">'</span><span class="s">add</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">remove</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">rewire</span><span class="sh">'</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">mutation_type</span> <span class="o">==</span> <span class="sh">'</span><span class="s">add</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">from_node</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">NUM_NODES_FIXED</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">to_node</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">NUM_NODES_FIXED</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">from_node</span> <span class="o">!=</span> <span class="n">to_node</span> <span class="ow">and</span> <span class="n">to_node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">from_node</span><span class="p">,</span> <span class="p">[]):</span>
                <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">add_edge</span><span class="p">(</span><span class="n">from_node</span><span class="p">,</span> <span class="n">to_node</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">mutation_type</span> <span class="o">==</span> <span class="sh">'</span><span class="s">remove</span><span class="sh">'</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">:</span>
                <span class="n">from_node</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">choice</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">.</span><span class="nf">keys</span><span class="p">()))</span>
                <span class="n">to_node</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">choice</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">from_node</span><span class="p">])</span>
                <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">from_node</span><span class="p">].</span><span class="nf">remove</span><span class="p">(</span><span class="n">to_node</span><span class="p">)</span>
                <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">to_node</span><span class="p">].</span><span class="nf">remove</span><span class="p">(</span><span class="n">from_node</span><span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">from_node</span><span class="p">]:</span>
                    <span class="k">del</span> <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">from_node</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">to_node</span><span class="p">]:</span>
                    <span class="k">del</span> <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">to_node</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">mutation_type</span> <span class="o">==</span> <span class="sh">'</span><span class="s">rewire</span><span class="sh">'</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">:</span>
                <span class="n">from_node</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">choice</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">.</span><span class="nf">keys</span><span class="p">()))</span>
                <span class="n">old_to_node</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">choice</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">from_node</span><span class="p">])</span>
                <span class="n">new_to_node</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">NUM_NODES_FIXED</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

                <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">from_node</span><span class="p">].</span><span class="nf">remove</span><span class="p">(</span><span class="n">old_to_node</span><span class="p">)</span>
                <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">old_to_node</span><span class="p">].</span><span class="nf">remove</span><span class="p">(</span><span class="n">from_node</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">new_to_node</span> <span class="o">!=</span> <span class="n">from_node</span> <span class="ow">and</span> <span class="n">new_to_node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">from_node</span><span class="p">,</span> <span class="p">[]):</span>
                    <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">add_edge</span><span class="p">(</span><span class="n">from_node</span><span class="p">,</span> <span class="n">new_to_node</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">self</span>

    <span class="k">def</span> <span class="nf">crossover</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="sh">"</span><span class="s">Chromosome</span><span class="sh">"</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="sh">"</span><span class="s">Chromosome</span><span class="sh">"</span><span class="p">]:</span>
        <span class="sh">"""</span><span class="s">
        Crossover strategies:
        1. Randomly combine edges from both parent chromosomes
        2. Create two offspring with mixed edge sets
        </span><span class="sh">"""</span>
        <span class="n">offspring1</span> <span class="o">=</span> <span class="nc">Chromosome</span><span class="p">()</span>
        <span class="n">offspring2</span> <span class="o">=</span> <span class="nc">Chromosome</span><span class="p">()</span>

        <span class="n">all_edges_parent1</span> <span class="o">=</span> <span class="nf">set</span><span class="p">()</span>
        <span class="n">all_edges_parent2</span> <span class="o">=</span> <span class="nf">set</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">from_node</span><span class="p">,</span> <span class="n">to_nodes</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">.</span><span class="nf">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">to_node</span> <span class="ow">in</span> <span class="n">to_nodes</span><span class="p">:</span>
                <span class="n">all_edges_parent1</span><span class="p">.</span><span class="nf">add</span><span class="p">((</span><span class="n">from_node</span><span class="p">,</span> <span class="n">to_node</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">from_node</span><span class="p">,</span> <span class="n">to_nodes</span> <span class="ow">in</span> <span class="n">other</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">.</span><span class="nf">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">to_node</span> <span class="ow">in</span> <span class="n">to_nodes</span><span class="p">:</span>
                <span class="n">all_edges_parent2</span><span class="p">.</span><span class="nf">add</span><span class="p">((</span><span class="n">from_node</span><span class="p">,</span> <span class="n">to_node</span><span class="p">))</span>

        <span class="n">combined_edges</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="n">all_edges_parent1</span><span class="p">.</span><span class="nf">union</span><span class="p">(</span><span class="n">all_edges_parent2</span><span class="p">))</span>
        <span class="n">random</span><span class="p">.</span><span class="nf">shuffle</span><span class="p">(</span><span class="n">combined_edges</span><span class="p">)</span>

        <span class="n">offspring1_edges</span> <span class="o">=</span> <span class="n">combined_edges</span><span class="p">[:</span><span class="nf">len</span><span class="p">(</span><span class="n">combined_edges</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">offspring2_edges</span> <span class="o">=</span> <span class="n">combined_edges</span><span class="p">[</span><span class="nf">len</span><span class="p">(</span><span class="n">combined_edges</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">:]</span>

        <span class="n">offspring1</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">offspring2</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">from_node</span><span class="p">,</span> <span class="n">to_node</span> <span class="ow">in</span> <span class="n">offspring1_edges</span><span class="p">:</span>
            <span class="n">offspring1</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">add_edge</span><span class="p">(</span><span class="n">from_node</span><span class="p">,</span> <span class="n">to_node</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">from_node</span><span class="p">,</span> <span class="n">to_node</span> <span class="ow">in</span> <span class="n">offspring2_edges</span><span class="p">:</span>
            <span class="n">offspring2</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">add_edge</span><span class="p">(</span><span class="n">from_node</span><span class="p">,</span> <span class="n">to_node</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">offspring1</span><span class="p">,</span> <span class="n">offspring2</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">genetic_algorithm</span><span class="p">():</span>
    <span class="c1"># Initialize population
</span>    <span class="n">population</span> <span class="o">=</span> <span class="p">[</span><span class="nc">Chromosome</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">POPULATION_SIZE</span><span class="p">)]</span>

    <span class="n">best_fitness_history</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Genetic Algorithm main loop
</span>    <span class="k">for</span> <span class="n">generation</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">MAX_ITERATIONS</span><span class="p">):</span>
        <span class="c1"># Evaluate fitness for each chromosome
</span>        <span class="n">fitness_scores</span> <span class="o">=</span> <span class="p">[</span><span class="n">chromosome</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">check_average_propagation_cost</span><span class="p">()</span> <span class="k">for</span> <span class="n">chromosome</span> <span class="ow">in</span> <span class="n">population</span><span class="p">]</span>

        <span class="c1"># Track best fitness in this generation
</span>        <span class="n">best_fitness</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">fitness_scores</span><span class="p">)</span>
        <span class="n">best_fitness_history</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">best_fitness</span><span class="p">)</span>

        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Generation </span><span class="si">{</span><span class="n">generation</span><span class="si">}</span><span class="s">: Best Fitness = </span><span class="si">{</span><span class="n">best_fitness</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

        <span class="c1"># Select top 20% chromosomes for reproduction
</span>        <span class="n">sorted_population</span> <span class="o">=</span> <span class="nf">sorted</span><span class="p">(</span><span class="nf">zip</span><span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="n">fitness_scores</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">top_population</span> <span class="o">=</span> <span class="p">[</span><span class="n">chrom</span> <span class="k">for</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">sorted_population</span><span class="p">[:</span><span class="n">POPULATION_SIZE</span><span class="o">//</span><span class="mi">5</span><span class="p">]]</span>

        <span class="c1"># Create new population through crossover and mutation
</span>        <span class="n">new_population</span> <span class="o">=</span> <span class="n">top_population</span><span class="p">.</span><span class="nf">copy</span><span class="p">()</span>

        <span class="k">while</span> <span class="nf">len</span><span class="p">(</span><span class="n">new_population</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">POPULATION_SIZE</span><span class="p">:</span>
            <span class="c1"># Select parents for crossover
</span>            <span class="n">parent1</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">choice</span><span class="p">(</span><span class="n">top_population</span><span class="p">)</span>
            <span class="n">parent2</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">choice</span><span class="p">(</span><span class="n">top_population</span><span class="p">)</span>

            <span class="c1"># Perform crossover
</span>            <span class="n">offspring</span> <span class="o">=</span> <span class="n">parent1</span><span class="p">.</span><span class="nf">crossover</span><span class="p">(</span><span class="n">parent2</span><span class="p">)</span>

            <span class="c1"># Optional mutation
</span>            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">offspring</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">random</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.8</span><span class="p">:</span>  <span class="c1"># 30% mutation rate
</span>                    <span class="n">child</span><span class="p">.</span><span class="nf">mutate</span><span class="p">()</span>

            <span class="n">new_population</span><span class="p">.</span><span class="nf">extend</span><span class="p">(</span><span class="n">offspring</span><span class="p">)</span>

        <span class="c1"># Truncate population to original size
</span>        <span class="n">population</span> <span class="o">=</span> <span class="n">new_population</span><span class="p">[:</span><span class="n">POPULATION_SIZE</span><span class="p">]</span>

    <span class="c1"># Return the best chromosome
</span>    <span class="n">best_chromosome</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">check_average_propagation_cost</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">best_chromosome</span>
</code></pre></div></div> <p>I tried with starting out with a fully-connected graph and removing edges, but it did not work out as good as this implementation (not sure why).</p> <p>The next (and final) part of the broadcast challenge is to make it more efficient. For this, we just need to batch out our messages; instead of sending one message at a time, we send <code class="language-plaintext highlighter-rouge">n</code> messages at a time. The message sending can work on a ticker, where we send deltas of messages every 100ms.</p> <h2 id="conclusion">Conclusion</h2> <p>This challenge was a lot of fun; esp. the genetic algorithm part. I had a lot of fun implementing it. The final part of the challenge was to batch out messages, which I did not include along with code for the last part in this tutorial for brevity. I will leave that as an exercise for the reader. The next challenges are counter-based challenges, and I plan to do them in go, like the way the engineers at fly.io intended. The code for this part can be found <a href="https://github.com/sandeshbhusal/gossip-glomers">here</a>.</p>]]></content><author><name></name></author><category term="distributed systems"/><category term="rust"/><category term="algorithms"/><summary type="html"><![CDATA[My solutions to the Gossip Glomers challenge by fly.io]]></summary></entry><entry><title type="html">Writing (rewriting) a lexer</title><link href="https://sandeshbhusal.github.io/blog/2024/lexers/" rel="alternate" type="text/html" title="Writing (rewriting) a lexer"/><published>2024-11-20T00:00:00+00:00</published><updated>2024-11-20T00:00:00+00:00</updated><id>https://sandeshbhusal.github.io/blog/2024/lexers</id><content type="html" xml:base="https://sandeshbhusal.github.io/blog/2024/lexers/"><![CDATA[<p>I’ve been working on a very small expression evaluation engine for my project <a href="https://github.com/sandeshbhusal/Hulaak">Hulaak</a> for quite a bit now. Aptly, the expression evaluation language is called Hulang, and it’s a very simple language that works on JSON documents to modify them, kind of like what <a href="https://jqlang.github.io/jq/">jq</a> does. The language implementation is still in its infancy, but I’ve been working on it on and off for a few days now, and this is my kinda-sorta journey of writing a lexer for the language.</p> <h2 id="before-you-proceed">Before you proceed</h2> <p>This post is quite code-heavy as I expect the posts in this series to be. All implementation is done in Rust, but should be portable to other languages with minimal changes. I will be using Rust’s <code class="language-plaintext highlighter-rouge">regex</code> crate for the first implementation, and then move on to a more conventional implementation. The code snippets are not complete, and are meant to be illustrative of the concepts I am discussing. The complete code can be found in the <a href="https://gist.github.com/sandeshbhusal/5de659c5081b42eaf668e1e5bf090feb">gist</a> at the end of the post.</p> <h2 id="the-theory">The theory</h2> <p>From my PL course, I remember that the purpose of a lexer is to:</p> <blockquote> <p>Take the input string and convert it into a stream of tokens.</p> </blockquote> <p>This does not really matter a whole lot when you’re working with a small stream of input; for a language like Hulang, it’s pretty trivial to implement this with Regexes. But considering the overengineer that I am, I wanted to implement a lexer that I could reuse for projects that I <em>might</em> work on in the future 😉.</p> <p>A lexer is a giant combined NFA, from my PL course. The NFA matches over the given input string, landing in “accept” states as it goes on, and the tokens are generated from the accept states. Once there is a single accept state, the lexer knows that it has found a token, and it can generate the token from the accept state. If there are multiple accept states, it is ambigious, since we do not know what kind of token we should emit. In that case, we can do the following:</p> <ul> <li>Choose the longest match, and emit the token from that state.</li> <li>If there are multiple longest matches, have precedence rules in-place so that we can select a single one..</li> </ul> <pre><code class="language-mermaid">stateDiagram-v2
    [*] --&gt; S0
    S0: Start State
    
    %% Path for identifiers starting with 'i'
    S0 --&gt; S1: i
    S1: After 'i'
    S1 --&gt; S2: f
    S1 --&gt; ID: a-z
    S1 --&gt; [*]: end input
    
    %% Path for all other identifiers
    S0 --&gt; ID: a-z
    
    %% State for 'if' keyword
    S2: Keyword 'if'
    S2 --&gt; ID: a-z
    S2 --&gt; [*]: end input
    
    %% Identifier state
    ID: Identifier
    ID --&gt; ID: a-z
    ID --&gt; [*]: end input
</code></pre> <p>Considering the NFA above, if the input is “ap”, then we land in the “Identifier” state, and we can emit an identifier. If we have a “if”, however, we land in <em>both</em> the “Identifier” and the “Keyword ‘if’” states. In this case, we can choose the longest match, which is “‘if’”, and then order by precedence rule to get keyword “if” and not identifier “if”. If there is an input of “ifa”, we get “if” as the longest match at length 2, but if we continue to match, we eventually only have “ifa” as an identifier, and do not emit “keyword if” followed by “identifier a”.</p> <h2 id="brute-implementation-in-rust">Brute implementation in Rust.</h2> <p>I know and love Rust, so I will be making a very simple implementation in Rust itself. The format can be extended to support multiple tokens, and symbols, but for now we’ll just work with three things - a “.” token, “if” keyword and “identifier”.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">TokenType</span> <span class="p">{</span>
    <span class="n">Identifier</span><span class="p">,</span>
    <span class="n">Dot</span><span class="p">,</span>
    <span class="n">If</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div> <p>Each of these token types will have an accompanying <code class="language-plaintext highlighter-rouge">Regex</code> pattern. We will make this pattern static.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">PATTERN_MAP</span><span class="p">:</span> <span class="n">LazyLock</span><span class="o">&lt;</span><span class="n">IndexMap</span><span class="o">&lt;&amp;</span><span class="k">'static</span> <span class="nb">str</span><span class="p">,</span> <span class="n">TokenType</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="nn">LazyLock</span><span class="p">::</span><span class="nf">new</span><span class="p">(||</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">map</span> <span class="o">=</span> <span class="nn">IndexMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">for</span> <span class="n">variant</span> <span class="k">in</span> <span class="nn">TokenType</span><span class="p">::</span><span class="nf">iter</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">pattern</span> <span class="o">=</span> <span class="k">match</span> <span class="n">variant</span> <span class="p">{</span>
            <span class="nn">TokenType</span><span class="p">::</span><span class="n">Dot</span> <span class="k">=&gt;</span> <span class="s">r"\."</span><span class="p">,</span>
            <span class="nn">TokenType</span><span class="p">::</span><span class="n">If</span> <span class="k">=&gt;</span> <span class="s">r"if"</span><span class="p">,</span>
            <span class="nn">TokenType</span><span class="p">::</span><span class="n">Identifier</span> <span class="k">=&gt;</span> <span class="s">r"[a-zA-Z]+"</span><span class="p">,</span>
        <span class="p">};</span>

        <span class="n">map</span><span class="nf">.insert</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">variant</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">map</span>
<span class="p">});</span>
</code></pre></div></div> <p>The tokens will be placed in a <code class="language-plaintext highlighter-rouge">Token</code> struct that marks the start, end, and content of the tokens (I know Rust has tagged unions that can hold data, but I like this way better).</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Token</span> <span class="p">{</span>
    <span class="n">start</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">end</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">token_type</span><span class="p">:</span> <span class="n">TokenType</span><span class="p">,</span>
    <span class="n">content</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div> <p>The Token type does heap allocation for the content, but I will omit using lifetimes for readability. The lexer will be a struct that holds the input string and the current position in the input string.</p> <h2 id="the-regex-lexer">The regex lexer</h2> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">lexer</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Token</span><span class="o">&gt;</span><span class="p">,</span> <span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Token</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">String</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre></div></div> <p>With this, we have the outline of a lexer that can match tokens and return them. The function takes in a string and returns a result that returns either:</p> <ul> <li>A successful result with a vector of tokens.</li> <li>An error with a vector of tokens that were successfully matched, and the remaining input string that was not matched.</li> </ul> <p>Now from the <a href="#the-theory">Theory</a>, we know that we need a giant DFA that will encompass all rules, and help us with the matching process. We can implement this giant DFA as a <a href="https://docs.rs/regex/latest/regex/struct.RegexSet.html">RegexSet</a> type that gives us the ability to match multiple regexes at once. We can then iterate over the matches and choose the longest match.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">lexer</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Token</span><span class="o">&gt;</span><span class="p">,</span> <span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Token</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">String</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">token</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">regex_dfa</span> <span class="o">=</span> <span class="nn">RegexSet</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">PATTERN_MAP</span><span class="nf">.keys</span><span class="p">())</span><span class="nf">.unwrap</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div> <p>Now the matching can begin. The algorithm goes like this:</p> <ol> <li>While the input string has a whitespace, skip the whitespace, and find an actual character we can start matching from.</li> <li>While the offset is less than the input string length, we can match tokens.</li> <li>Match the regex set with the input string, and get the longest match at the offset.</li> <li>If there is no match, return an error with the tokens matched so far, and the remaining input string.</li> </ol> <p>The code looks like this:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">lexer</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Token</span><span class="o">&gt;</span><span class="p">,</span> <span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Token</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">String</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">tokens</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">regex_dfa</span> <span class="o">=</span> <span class="nn">RegexSet</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">PATTERN_MAP</span><span class="nf">.keys</span><span class="p">())</span><span class="nf">.unwrap</span><span class="p">();</span>

    <span class="k">while</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="n">input</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">off</span><span class="p">,</span> <span class="n">_</span><span class="p">))</span> <span class="o">=</span> <span class="n">input</span>
            <span class="nf">.chars</span><span class="p">()</span>
            <span class="nf">.enumerate</span><span class="p">()</span>
            <span class="nf">.find</span><span class="p">(|(</span><span class="n">off</span><span class="p">,</span> <span class="n">ip</span><span class="p">)|</span> <span class="o">*</span><span class="n">off</span> <span class="o">&gt;=</span> <span class="n">offset</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ip</span><span class="nf">.is_whitespace</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">off</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">tokens</span><span class="p">);</span> <span class="c1">// Nothing except whitespaces found. Return lexed this far.</span>
        <span class="p">}</span>

        <span class="c1">// Get all matches for the current offset.</span>
        <span class="k">let</span> <span class="n">matched_patterns_index</span> <span class="o">=</span> <span class="n">regex_dfa</span><span class="nf">.matches</span><span class="p">(</span><span class="o">&amp;</span><span class="n">input</span><span class="p">[</span><span class="n">offset</span><span class="o">..</span><span class="p">]);</span>
        <span class="k">if</span> <span class="n">matched_patterns_index</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Err</span><span class="p">((</span><span class="n">tokens</span><span class="p">,</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">input</span><span class="p">[</span><span class="n">offset</span><span class="o">..</span><span class="p">])</span><span class="nf">.to_string</span><span class="p">()));</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">matched_strings_and_types</span> <span class="o">=</span> <span class="n">matched_patterns_index</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">pattern_index</span><span class="p">|</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">pattern_str</span> <span class="o">=</span> <span class="n">PATTERN_MAP</span><span class="nf">.keys</span><span class="p">()</span><span class="nf">.nth</span><span class="p">(</span><span class="n">pattern_index</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">token_type</span> <span class="o">=</span> <span class="n">PATTERN_MAP</span><span class="nf">.get</span><span class="p">(</span><span class="n">pattern_str</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">matched_string</span> <span class="o">=</span> <span class="nn">Regex</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">pattern_str</span><span class="p">)</span>
                <span class="nf">.expect</span><span class="p">(</span><span class="s">"Invalid regex pattern -- This should never happen"</span><span class="p">)</span>
                <span class="nf">.find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">input</span><span class="p">[</span><span class="n">offset</span><span class="o">..</span><span class="p">])</span>
                <span class="nf">.unwrap</span><span class="p">()</span>
                <span class="nf">.as_str</span><span class="p">();</span>
            <span class="p">(</span><span class="n">token_type</span><span class="p">,</span> <span class="n">matched_string</span><span class="p">)</span>
        <span class="p">});</span>

        <span class="k">let</span> <span class="n">longest_match</span> <span class="o">=</span> <span class="n">matched_strings_and_types</span>
            <span class="nf">.max_by_key</span><span class="p">(|(</span><span class="n">_tokentype</span><span class="p">,</span> <span class="n">matched</span><span class="p">)|</span> <span class="n">matched</span><span class="nf">.len</span><span class="p">())</span>
            <span class="nf">.expect</span><span class="p">(</span><span class="s">"Something should've matched"</span><span class="p">);</span>

        <span class="k">let</span> <span class="p">(</span><span class="n">token_type</span><span class="p">,</span> <span class="n">matched_string</span><span class="p">)</span> <span class="o">=</span> <span class="n">longest_match</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">start</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">end</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">matched_string</span><span class="nf">.len</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">r</span><span class="err">#</span><span class="k">type</span> <span class="o">=</span> <span class="o">*</span><span class="n">token_type</span><span class="p">;</span>

        <span class="n">tokens</span><span class="nf">.push</span><span class="p">(</span><span class="n">Token</span> <span class="p">{</span>
            <span class="n">r</span><span class="err">#</span><span class="k">type</span><span class="p">,</span>
            <span class="n">start</span><span class="p">,</span>
            <span class="n">end</span><span class="p">,</span>
            <span class="n">content</span><span class="p">:</span> <span class="n">matched_string</span><span class="nf">.to_string</span><span class="p">(),</span>
        <span class="p">});</span>

        <span class="n">offset</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nf">Ok</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p>The regexset returns a iterable of indexes of the matched patterns, and we can then get the matched string from the input string. We then find the longest match, and create a token from that match. The offset is then moved to the end of the matched string, and the process continues until the end of the input string.</p> <h3 id="issues-with-this-implementation">Issues with this implementation</h3> <p>The implementation is quite elegant at the first glance - to add more tokens, we just add them to the <code class="language-plaintext highlighter-rouge">TokenType</code> map, and the <code class="language-plaintext highlighter-rouge">PATTERN_MAP</code>. The lexer token types are ordered by default in the TokenType map (the latter tokens in the enum have more precedence than the upper tokens), so we don’t need to worry about breaking ties. The issues with this implementation are:</p> <ul> <li>Usage of RegexSet and Regex is not very performant.</li> <li>In most cases, the conflicts arise with matching “identifier” and “token” types from my experience. It is not worth it to use Regex for this case.</li> <li>We may not want to “eat” whitespace all the time - we have cases like matching string literals where we would like to keep the whitespace (albeit this can be solved by adding a new regex type for string literal).</li> </ul> <p>I glossed over the lexer implementation of lexers that <a href="https://brunocalza.me/writing-a-simple-lexer-in-rust/">other people have done</a> and this implementation looks unnecessarily brute-forcy.</p> <h2 id="writing-a-better-lexer">Writing a better lexer.</h2> <p>I want the implementation of the lexer to be more performant, and more conventional - in tune with what people in the industry actually do instead of creating a large messy RegexSet to hide from the actual implementation. If you think about it, it’s really simple - the conflicts generally arise when matching inputs like “if” and “identifier”, or “&gt;=” and “&gt;” and “=”.</p> <p>The lexer in this case will become a simple state matchine we can code by-hand. We start by reusing the token_type enum and token struct from before, and defining a lexer struct. The struct looks like this:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">Lexer</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="nb">char</span><span class="p">],</span>
    <span class="n">position</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div> <p>Since rust has excellent default support for Unicode characters, we can use <code class="language-plaintext highlighter-rouge">char</code> type. Next, we begin by defining some basic operations on the lexer struct.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">LexerResult</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">LexerError</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">Lexer</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="nb">char</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="n">Lexer</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="n">Lexer</span> <span class="p">{</span> <span class="n">input</span><span class="p">,</span> <span class="n">position</span><span class="p">:</span> <span class="mi">0</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">peek</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">char</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="k">if</span> <span class="k">self</span><span class="py">.position</span> <span class="o">&gt;=</span> <span class="k">self</span><span class="py">.input</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">(</span><span class="k">self</span><span class="py">.input</span><span class="p">[</span><span class="k">self</span><span class="py">.position</span><span class="p">])</span>
        <span class="p">};</span>

        <span class="n">res</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">advance</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">LexerResult</span><span class="o">&lt;</span><span class="nb">char</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.position</span> <span class="o">&gt;=</span> <span class="k">self</span><span class="py">.input</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">LexerError</span><span class="p">::</span><span class="n">EndOfInput</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="nf">Ok</span><span class="p">(</span><span class="k">self</span><span class="py">.input</span><span class="p">[</span><span class="k">self</span><span class="py">.position</span><span class="p">]);</span>
        <span class="k">self</span><span class="py">.position</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">res</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">eat_whitespace</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">LexerResult</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.peek</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="o">!</span><span class="n">ch</span><span class="nf">.is_whitespace</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.advance</span><span class="p">()</span><span class="o">?</span><span class="p">;</span> <span class="c1">// Discard the whitespace.</span>
        <span class="p">}</span>
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>All the functions are pretty self-explanatory. We begin by creating a lexer that tracks the position in the input string. We can peek at the current character, advance the position, and eat whitespace.</p> <p>Now we need a function that actuallly does the lexing.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">lex</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">LexerResult</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Token</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">tokens</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Token</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="c1">// Start, eat whitespace.</span>
    <span class="k">self</span><span class="nf">.eat_whitespace</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Match the first character.</span>
    <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">current_char</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.peek</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">current_char</span> <span class="p">{</span>
            <span class="sc">'a'</span><span class="o">..</span><span class="sc">'z'</span> <span class="p">|</span> <span class="sc">'A'</span><span class="o">..</span><span class="sc">'Z'</span> <span class="p">|</span> <span class="sc">'_'</span> <span class="k">=&gt;</span> <span class="n">tokens</span><span class="nf">.push</span><span class="p">(</span><span class="k">self</span><span class="nf">.match_identifier_or_keyword</span><span class="p">()</span><span class="o">?</span><span class="p">),</span>
            <span class="n">symb</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">tok_type</span> <span class="o">=</span> <span class="k">match</span> <span class="n">symb</span> <span class="p">{</span>
                    <span class="sc">'.'</span> <span class="k">=&gt;</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">Dot</span><span class="p">,</span>
                    <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">LexerError</span><span class="p">::</span><span class="nf">PartiallyMatchedInput</span><span class="p">(</span>
                            <span class="n">tokens</span><span class="p">,</span>
                            <span class="k">self</span><span class="py">.input</span><span class="p">[</span><span class="k">self</span><span class="py">.position</span><span class="o">..</span><span class="p">]</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.collect</span><span class="p">(),</span>
                        <span class="p">))</span>
                    <span class="p">}</span>
                <span class="p">};</span>

                <span class="n">tokens</span><span class="nf">.push</span><span class="p">(</span><span class="n">Token</span> <span class="p">{</span>
                    <span class="n">start</span><span class="p">:</span> <span class="k">self</span><span class="py">.position</span><span class="p">,</span>
                    <span class="n">end</span><span class="p">:</span> <span class="k">self</span><span class="py">.position</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="n">token_type</span><span class="p">:</span> <span class="n">tok_type</span><span class="p">,</span>
                    <span class="n">content</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="k">self</span><span class="nf">.advance</span><span class="p">()</span><span class="o">?</span><span class="p">),</span>
                <span class="p">});</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">self</span><span class="nf">.eat_whitespace</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// End, eat all whitespace</span>
    <span class="k">self</span><span class="nf">.eat_whitespace</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="k">return</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">tokens</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>The lex function starts off by creating the return array of tokens. Then we discard all whitespace until we hit a char we can parse. Based on the char at the start of the input stream, we can match either an identifier/keyword, or a symbol (our symbol is limited to just ‘.’ for now). The match_identifier_or_keyword function is a helper function that matches the identifier or keyword.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    <span class="k">fn</span> <span class="nf">match_identifier_or_keyword</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">LexerResult</span><span class="o">&lt;</span><span class="n">Token</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">start</span> <span class="o">=</span> <span class="k">self</span><span class="py">.position</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">startsym</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.advance</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">buffer</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">startsym</span><span class="p">);</span>
        
        <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.peek</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ch</span><span class="nf">.is_ascii_alphanumeric</span><span class="p">()</span> <span class="p">||</span> <span class="n">ch</span> <span class="o">==</span> <span class="sc">'_'</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ch</span><span class="nf">.is_whitespace</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">buffer</span><span class="nf">.push</span><span class="p">(</span><span class="k">self</span><span class="nf">.advance</span><span class="p">()</span><span class="o">?</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">kwmatch</span> <span class="o">=</span> <span class="k">match</span> <span class="n">buffer</span><span class="nf">.as_ref</span><span class="p">()</span> <span class="p">{</span>
            <span class="s">"if"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">KwIf</span><span class="p">),</span>
            <span class="n">_</span> <span class="k">=&gt;</span> <span class="nb">None</span><span class="p">,</span>
        <span class="p">};</span>

        <span class="k">return</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">Token</span> <span class="p">{</span>
            <span class="n">start</span><span class="p">,</span>
            <span class="n">end</span><span class="p">:</span> <span class="n">start</span> <span class="o">+</span> <span class="n">buffer</span><span class="nf">.len</span><span class="p">(),</span>
            <span class="n">token_type</span><span class="p">:</span> <span class="n">kwmatch</span><span class="nf">.unwrap_or</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">Identifier</span><span class="p">),</span>
            <span class="n">content</span><span class="p">:</span> <span class="n">buffer</span><span class="p">,</span>
        <span class="p">});</span>
    <span class="p">}</span>
</code></pre></div></div> <p>The function begins by reading off the start char into a string itself. Then until we have ascii alphanumeric char or “_” in the input stream, we will continue to push it into the buffer. When we hit a non-alphanumeric char, we break out of the loop and check if the buffer is a keyword. If it is, we return the keyword token, else we return the identifier token.</p> <p>The lexer is now complete. The complete lexer code looks like <a href="https://gist.github.com/sandeshbhusal/5de659c5081b42eaf668e1e5bf090feb">this</a>.</p> <h2 id="concluding-remarks">Concluding remarks</h2> <p>I had a lot of fun writing (and rewriting) this lexer. While the task of writing something by hand might sound daunting at first, and we might immediately want to run off to write code with libraries like <code class="language-plaintext highlighter-rouge">Regex</code>, it can be beneficial to write code by hand sometimes to solidify understanding and challenge oneself. The lexer implementation above is very simple - we can improve further on it, e.g. by adding support for string literals, comments, and other symbols. The lexer can be extended to support more complex languages, and can be used as a base for writing a parser for the language. There is also the opportunity for performance optimization - we could remove all memory allocations and use slices instead of strings, and we could also use a more efficient data structure to store the tokens. However, those are topics for another day.</p> <p>I hope you enjoyed reading this post. If you have any feedback, feel free to reach out to me on <a href="https://linkedin.com/in/sandeshbhusal">LinkedIn</a>. I’m always open to feedback and suggestions. Until next time, happy coding! 🚀</p>]]></content><author><name></name></author><category term="algorithms"/><category term="programming languages"/><summary type="html"><![CDATA[A journey of writing a lexer for a simple language in Rust.]]></summary></entry><entry><title type="html">Writing a Baremetal Bootloader for STM32 (no sdk)</title><link href="https://sandeshbhusal.github.io/blog/2024/tinkering-with-stm32/" rel="alternate" type="text/html" title="Writing a Baremetal Bootloader for STM32 (no sdk)"/><published>2024-08-05T00:00:00+00:00</published><updated>2024-08-05T00:00:00+00:00</updated><id>https://sandeshbhusal.github.io/blog/2024/tinkering-with-stm32</id><content type="html" xml:base="https://sandeshbhusal.github.io/blog/2024/tinkering-with-stm32/"><![CDATA[<p>For a change of pace, I wanted to work on an embedded project, but being the “systems programmer” that I am, without a proper working knowledge of the electrical signals (well, I do have a degree, but it’s not in electrical engineering), I decided to tinker with the STM32 microcontroller. After borrowing one from a friend (thanks, Royce!) I started to tinker with it, but I found myself working with a STM32 Cube IDE, and that just won’t do, will it?</p> <h2 id="qemu">QEMU</h2> <p><br/></p> <p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/45/Qemu_logo.svg/1024px-Qemu_logo.svg.png" alt="QEMU Logo"/></p> <p><br/></p> <p>Enter QEMU. It is a virtual machine that emulates a CPU, and it is very useful for testing and debugging embedded software. After a brief hiatus with the STM32 Cube IDE, I decided to give it a try, because I wanted to try out other boards, and test my mettle with other boards, and a barebones approach. I had been using autogenerated codebases from the STM32 Cube IDE, and a lot of things are hidden under the hood. Becoming and embedded engineer would require me to interface directly with unknown hardware, for which no SDK exists (maybe I would have to write my own)!</p> <p>For simplicity’s sake, I decided to work with the netduinoplus2 board, which is supported by QEMU, under the machine name of “netduinoplus2”. It is a arm cortex-m4 board, which was analogous to the stm32-f4discovery board I borrowed from my friend.</p> <h2 id="finding-stuff">Finding stuff?</h2> <p>Now that I had my board, I needed a workflow. Trying to to cheat <em>too much</em> from lowlevel learning on youtube (his tutorials are aweeeeeesome btw), I gathered the information about the necessary bits from the internet, and his videos. Here were the basic things I would need:</p> <ul> <li>A toolchain</li> <li>A bootloader (mayhaps not, I will explain this later)</li> <li>A linker script</li> <li>Build system</li> </ul> <h3 id="toolchain">Toolchain</h3> <p>This was trivial. I had a working toolchain, and I just needed to add the necessary bits to make it work with the board.</p> <h3 id="a-linker-script">A Linker Script</h3> <p>This is where I spent most of my time. First of all, the linker script needs the memory map of the board. I looked at the description of the netduinoplus2 board on the QEMU docs, and <a href="https://github.com/qemu/qemu/blob/master/docs/system/arm/stm32.rst">found that it uses STM32F405RGT6 microcontroller</a>. I wanted the memory map but I was too lazy to check out the datasheet, so I poked around the qemu repo inside <a href="https://github.com/qemu/qemu/blob/master/hw/arm/netduinoplus2.c">https://github.com/qemu/qemu/blob/master/hw/arm/netduinoplus2.c</a>, but I didn’t find anything. Oh well. After a quick search, I found the <a href="hehe">datasheet</a> and the rest is history. Well, not really.</p> <p>Inside the datasheet, I found the memory map. The way netduinoplus2 boots up is configured by the boot-up pins, and the inital couple of bytes in the memory map (4G) are aliased depending on the boot pin configuration. In my case, it would boot up directly from flash which is at <code class="language-plaintext highlighter-rouge">0x08000000</code>.</p> <p><img src="/images/stm32_mmap.png" alt="Memory Map"/></p> <h3 id="build-system">Build System</h3> <p>I used my trusty old mate, ‘Make’ for this purpose. I also wanted to use gdb to debug the code, which the toolchain brings along with it.</p> <h2 id="the-adventure-begins">The adventure begins</h2> <p>Armed with my half-baked knowledge of writing .. well .. everything, I started my journey. I had a head full of ideas, eyes full of dreams, and brain full of nothing. So I wrote this.</p> <h3 id="a-simple-main">A simple main</h3> <p>Our main does not need to do a lot. It just needs to exist. And well, loop.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>Then this will get compiled with a “stub bootloader”. IDK where I got this idea, but the concept of mixing the arm assembly (and learning a bit of it), and calling C code sounded too sexy to pass up.</p> <div class="language-as highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">.</span><span class="nx">extern</span> <span class="nx">main</span>
<span class="p">.</span><span class="nx">global</span> <span class="nx">_start</span>

<span class="nl">_start</span><span class="p">:</span>
    <span class="nx">b</span> <span class="nx">main</span>
</code></pre></div></div> <p>Then our linker script will come into play and help us organize these bits:</p> <pre><code class="language-ld">ENTRY(_start)

MEMORY{
     FLASH ( rw ) : ORIGIN = 0x08000000 , LENGTH = 1M
     RAM ( xrw) : ORIGIN = 0x20000000 , LENGTH = 112K
}

SECTIONS
{
    . = 0x8000;

    .text :
    {
        *(.text._start)        /* Ensure _start is placed first */
        *(.text*)              /* All other .text sections from input files */
        *(.rodata*)            /* Read-only data */
    } &gt; FLASH
}
</code></pre> <p>Since I am too poor at maths, I used an online calculator to find the lengths of the memory regions. Ahh, the code is looking sexy already.</p> <p>Now, to tie it all together, I need a makefile.</p> <div class="language-make highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">TARGET</span><span class="o">=</span>arm-none-eabi
<span class="nv">CORTEX</span><span class="o">=</span>cortex-m4
<span class="nv">CFLAGS</span><span class="o">=</span><span class="nt">-nostartfiles</span>

<span class="nv">CC</span><span class="o">=</span><span class="p">${</span>TARGET<span class="p">}</span><span class="nt">-gcc</span>
<span class="nv">LD</span><span class="o">=</span><span class="p">${</span>TARGET<span class="p">}</span><span class="nt">-ld</span>
<span class="nv">AS</span><span class="o">=</span><span class="p">${</span>TARGET<span class="p">}</span><span class="nt">-as</span>

<span class="nv">OBJDUMP</span><span class="o">=</span><span class="p">${</span>TARGET<span class="p">}</span><span class="nt">-objdump</span>
<span class="nv">OBJCOPY</span><span class="o">=</span><span class="p">${</span>TARGET<span class="p">}</span><span class="nt">-objcopy</span>

<span class="nl">all</span><span class="o">:</span> <span class="nf">kernel.o</span>

<span class="nl">boot.o</span><span class="o">:</span> <span class="nf">boot.s</span>
        <span class="err">${AS}</span> <span class="nv">-mcpu</span><span class="o">=</span><span class="p">${</span>CORTEX<span class="p">}</span> <span class="nt">-g</span> boot.s <span class="nt">-o</span> boot.o

<span class="nl">main.o</span><span class="o">:</span> <span class="nf">main.c</span>
        <span class="err">${CC}</span> <span class="err">${CFLAGS}</span> <span class="err">-g</span> <span class="err">-nostdlib</span> <span class="nv">-mcpu</span><span class="o">=</span><span class="p">${</span>CORTEX<span class="p">}</span> <span class="nt">-c</span> main.c <span class="nt">-o</span> main.o

<span class="nl">kernel.o</span><span class="o">:</span> <span class="nf">main.o boot.o</span>
        <span class="err">${LD}</span> <span class="err">-T</span> <span class="err">linker.ld</span> <span class="err">main.o</span> <span class="err">boot.o</span> <span class="err">-o</span> <span class="err">kernel.o</span>

<span class="nl">clean</span><span class="o">:</span>
        <span class="err">rm</span> <span class="err">-rf</span> <span class="err">*.o</span> <span class="err">*.elf</span>
</code></pre></div></div> <p>Just look at that makefile. So clean. So concise. So sexy…</p> <p><img src="https://a.pinatafarm.com/680x848/03f5bb020a/anthony-adams-rubbing-hands.jpg" width="400"/></p> <p>Well, I digress. Now the time to run everything.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>% make
arm-none-eabi-gcc <span class="nt">-nostartfiles</span> <span class="nt">-nostdlib</span> <span class="nt">-mcpu</span><span class="o">=</span>cortex-m4 <span class="nt">-g</span> <span class="nt">-c</span> main.c <span class="nt">-o</span> main.o
arm-none-eabi-gcc <span class="nt">-nostartfiles</span> <span class="nt">-nostdlib</span> <span class="nt">-mcpu</span><span class="o">=</span>cortex-m4 <span class="nt">-g</span> <span class="nt">-c</span> boot.c <span class="nt">-o</span> boot.o
arm-none-eabi-ld <span class="nt">-T</span> linker.ld main.o boot.o <span class="nt">-o</span> kernel.elf

% qemu-system-arm <span class="nt">-M</span> netduinoplus2 <span class="nt">-nographic</span> <span class="nt">-kernel</span> kernel.o
qemu: fatal: Lockup: can<span class="s1">'t escalate 3 to HardFault (current priority -1)

R00=00000000 R01=00000000 R02=00000000 R03=00000000
R04=00000000 R05=00000000 R06=00000000 R07=00000000
R08=00000000 R09=00000000 R10=00000000 R11=00000000
R12=00000000 R13=af00b460 R14=fffffff9 R15=00000000
XPSR=40000003 -Z-- A handler
s00=00000000 s01=00000000 d00=0000000000000000
s02=00000000 s03=00000000 d01=0000000000000000
s04=00000000 s05=00000000 d02=0000000000000000
s06=00000000 s07=00000000 d03=0000000000000000
s08=00000000 s09=00000000 d04=0000000000000000
s10=00000000 s11=00000000 d05=0000000000000000
s12=00000000 s13=00000000 d06=0000000000000000
s14=00000000 s15=00000000 d07=0000000000000000
s16=00000000 s17=00000000 d08=0000000000000000
s18=00000000 s19=00000000 d09=0000000000000000
s20=00000000 s21=00000000 d10=0000000000000000
s22=00000000 s23=00000000 d11=0000000000000000
s24=00000000 s25=00000000 d12=0000000000000000
s26=00000000 s27=00000000 d13=0000000000000000
s28=00000000 s29=00000000 d14=0000000000000000
s30=00000000 s31=00000000 d15=0000000000000000
FPSCR: 00000000
zsh: abort      qemu-system-arm -M netduinoplus2 -nographic -kernel kernel.o
</span></code></pre></div></div> <p>This led me to a profound realization - this is why embedded engineers are so hard to find (and unhinged).</p> <h2 id="analyzing-the-crash">Analyzing the crash</h2> <p>No matter how hard I tried, I couldn’t find the cause of the crash. Surprisingly, it is easier to find the tutorial on Rust (mi cheri) than on C (mi cherry). I was able to find some blog posts, but they just were not working out. Turns out, I had my linker script all wrong.</p> <h3 id="looking-at-the-linker-script">Looking at the linker script</h3> <p>A quick look at the linker script shows a fatal flaw: 0x8000 is not the start of the .text section. So that line went away. After a couple of 5-minutes of debugging, I found the problem. The glaring issue. The bane of my code. (<em>add more drama here</em>).</p> <h4 id="the-ivt">The IVT</h4> <p>The interrupt vector table is a table of addresses of the interrupt handlers. The first entry in the IVT is the stack pointer base, followed by the reset handler, the nmi handler, the hard fault handler, and so on.</p> <p>The reset handler is the first thing that runs when the processor boots up.</p> <p>I did not have that.</p> <p>Ugh.</p> <p>The rectification was simple.</p> <pre><code class="language-ld">MEMORY
{
    FLASH (rx) : ORIGIN = 0x08000000, LENGTH = 1M
    RAM (rwx)  : ORIGIN = 0x20000000, LENGTH = 112K
}

SECTIONS
{
    .text :
    {
        *(.text._start)        /* Ensure _start is placed first */
        *(.text*)              /* All other .text sections */
        *(.rodata*)            /* Read-only data */
        . = ALIGN(4);
    } &gt; FLASH
}
</code></pre> <h4 id="the-bootloader">The bootloader</h4> <p>The bootloader was mostly fine. I was thinking about the bootloader-main connection, and I thought that it would be best to initialize the IVT in the bootloader, and then jump to the main. So I set about writing the IVT in the bootloader. In the end, I removed the bootloader asm, and rewrite the bootloader in C.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp">
</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="c1">// Stack top starts at the end of the ram boundary. </span>
<span class="c1">// This is technically the last mem location we can access.</span>
<span class="c1">// https://www.st.com/resource/en/datasheet/stm32f405rg.pdf</span>
<span class="cp">#define STACK_TOP 0x20010000
</span>
<span class="c1">// The entry function (mentioned in our linker script).</span>
<span class="c1">// IDK What else I should add at this point, as this can be main instead of this.</span>
<span class="kt">void</span> <span class="nf">_start</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">main</span><span class="p">();</span>  <span class="c1">// Call the main function</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>  <span class="c1">// Infinite loop to prevent falling off the end. In case main exits.</span>
<span class="p">}</span>

<span class="c1">// NOTE: SUPERR important. If this does not exist, the CPU will NOT take us to the</span>
<span class="c1">// _start function, i.e. reset handler.</span>
<span class="c1">// Interrupt Vector Table</span>
<span class="n">__attribute__</span><span class="p">((</span><span class="n">section</span><span class="p">(</span><span class="s">".isr_vector"</span><span class="p">)))</span>
<span class="kt">uint32_t</span> <span class="n">isr_vector</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">STACK_TOP</span><span class="p">,</span>          <span class="c1">// Initial Stack Pointer</span>
    <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">_start</span><span class="p">,</span>  <span class="c1">// Reset Handler</span>
<span class="p">};</span>
</code></pre></div></div> <p>It’s a bit of a mess? but it works.</p> <h4 id="the-main">The main</h4> <p>The main is pretty much the same. Pretty and useless.</p> <h2 id="running--debugging">Running + debugging</h2> <p>Now I recompiled everything. It compiled fine. Now was the time to run it with qemu. It hung up.</p> <p>The question remains - did it hang up in the bootloader loop, or did it hang up in the main loop? I wasn’t sure. Enter, gdb.</p> <p>Running gdb with the qemu binary is pretty simple; in one pane, you run the qemu binary, and in the other one, run gdb. In the pane with qemu, run it like:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>qemu-system-arm <span class="nt">-M</span> netduinoplus2 <span class="nt">-nographic</span> <span class="nt">-kernel</span> kernel.elf <span class="nt">-gdb</span> tcp::4444 <span class="nt">-S</span>
</code></pre></div></div> <p><sup id="fnref:1"><a href="#fn:1" class="footnote" rel="footnote" role="doc-noteref">1</a></sup></p> <p>This suspends the execution of the kernel (which we will resume from gdb).</p> <p>In the gdb pane, run gdb like:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>% arm-none-eabi-gdb kernel.elf                                                                                                                                                     <span class="o">(</span>main x!?<span class="o">)</span>
GNU gdb <span class="o">(</span>GNU Arm Embedded Toolchain 10.3-2021.10<span class="o">)</span> 10.2.90.20210621-git
Copyright <span class="o">(</span>C<span class="o">)</span> 2021 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type <span class="s2">"show copying"</span> and <span class="s2">"show warranty"</span> <span class="k">for </span>details.
This GDB was configured as <span class="s2">"--host=x86_64-apple-darwin10 --target=arm-none-eabi"</span><span class="nb">.</span>
Type <span class="s2">"show configuration"</span> <span class="k">for </span>configuration details.
For bug reporting instructions, please see:
&lt;https://www.gnu.org/software/gdb/bugs/&gt;.
Find the GDB manual and other documentation resources online at:
    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.

For <span class="nb">help</span>, <span class="nb">type</span> <span class="s2">"help"</span><span class="nb">.</span>
Type <span class="s2">"apropos word"</span> to search <span class="k">for </span>commands related to <span class="s2">"word"</span>...
Reading symbols from kernel.elf...
</code></pre></div></div> <p>Then attach to the gdb session:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> target remote localhost:4444
Remote debugging using localhost:4444
_start <span class="o">()</span> at boot.c:12
12      void _start<span class="o">(</span>void<span class="o">)</span> <span class="o">{</span>
<span class="o">(</span>gdb<span class="o">)</span> <span class="nb">break </span>main
Breakpoint 1 at 0x800000c: file main.c, line 3.
</code></pre></div></div> <p>Finally, continue the execution:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> c
Continuing.

Breakpoint 1, main <span class="o">()</span> at main.c:3
3           <span class="k">while</span><span class="o">(</span>1<span class="o">)</span><span class="p">;</span>
<span class="o">(</span>gdb<span class="o">)</span>
</code></pre></div></div> <p>And voila! We are in main.</p> <p><img src="/images/debug_panes.png" alt="debug"/></p> <h2 id="what-did-we-learn-whats-moving-forward">What did we learn? What’s moving forward?</h2> <p>It’s more about what I learned:</p> <ul> <li>It’s not easy to debug embedded software unless you get into a debug env. Before a debug env, I cannot imagine how hard it is to debug a program.</li> <li>IVT is a cool thing. Don’t forget it.</li> <li>A lot of infrastructure has gone into building these toolchains (qemu, gdb, linker scripts, etc.). I came to have a deep sense of appreciation for all the engineers who develop that.</li> </ul> <p>Now that I have a somewhat working program, I can start to think about how to make it more useful. I am thinking about exploring Rust (esp in RISC-V) for my upcoming posts, since I recently bought a Milk-V board (which is super cool). Here’s to learning a lot, and I hope to see you in the future.</p> <hr/> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:1"> <p>If you omit one of the colons in the <code class="language-plaintext highlighter-rouge">tcp::4444</code>, the qemu gods will be very very angry with you. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div>]]></content><author><name></name></author><category term="embedded"/><category term="stm32"/><summary type="html"><![CDATA[For a change of pace, I wanted to work on an embedded project, but being the “systems programmer” that I am, without a proper working knowledge of the electrical signals (well, I do have a degree, but it’s not in electrical engineering), I decided to tinker with the STM32 microcontroller. After borrowing one from a friend (thanks, Royce!) I started to tinker with it, but I found myself working with a STM32 Cube IDE, and that just won’t do, will it?]]></summary></entry><entry><title type="html">Binary search is Bananas!</title><link href="https://sandeshbhusal.github.io/blog/2023/binary-search/" rel="alternate" type="text/html" title="Binary search is Bananas!"/><published>2023-08-19T00:00:00+00:00</published><updated>2023-08-19T00:00:00+00:00</updated><id>https://sandeshbhusal.github.io/blog/2023/binary-search</id><content type="html" xml:base="https://sandeshbhusal.github.io/blog/2023/binary-search/"><![CDATA[<h2 id="refresher">Refresher</h2> <p>Binary search is one of the most trivial and elegant algorithms to understand, and yet, equally easy to get wrong while implementing it. There are a couple of checkpoints, comparisons and constants, which contribute to the running of the algorithm, which can be easily mistaken. In essence, binary search works by partitioning a given array into two halves successively, until a single element (or position) is reached where the target of interest may be. This means, during each run of the algorithm, we have the following choices to make:</p> <ul> <li>Has the algorithm terminated? If so, has it found the target (or position)?</li> <li>Which array is the array of interest currently, and which subsection will we explore next?</li> <li>Will the algorithm / loop terminate?</li> </ul> <p>Binary search keeps track of position information in two pointers (although a variant of <a href="https://www.geeksforgeeks.org/meta-binary-search-one-sided-binary-search/">one-sided binary search</a> is also possible). These pointers, can be called <code class="language-plaintext highlighter-rouge">low</code> and <code class="language-plaintext highlighter-rouge">high</code>, and represent the range of the array we are searching within (inclusive), i.e. <code class="language-plaintext highlighter-rouge">[low, high]</code>.</p> <h2 id="pseudocode">Pseudocode</h2> <p>Let’s proceed with a simple pseudocode implementation which leaves a lot of blanks out to be filled in later on (proofs, etc). It looks something like this:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">binarysearch</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">low</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="n">__</span><span class="p">,</span> <span class="n">__</span>
    <span class="k">while</span> <span class="n">low</span> <span class="n">__</span> <span class="n">high</span><span class="p">:</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">low</span> <span class="o">+</span> <span class="n">high</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">array</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mid</span>
        <span class="k">if</span> <span class="n">array</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="n">__</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">low</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="n">__</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">high</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="n">__</span>

    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div></div> <p>You must’ve noticed a few blanks in the pseudocode above. Don’t worry - we’ll fill them later on. For now, let’s define some properties we’d like the algorithm to have.</p> <h3 id="desired-properties">Desired properties.</h3> <p>Like the questions above, the desired properties for the algorithm can be described as follows:</p> <h4 id="correctness">Correctness:</h4> <ul> <li>The Algorithm must always produce a correct answer. That is, if an element exists in the array, it should return the index of the said element. Otherwise, it should return -1. If an element exists and the algorithm returns -1, it is incorrect, and the same can be said when a non-existing element search returns an index within the array.</li> </ul> <blockquote> <p>This kind of issue generally manifests itself in corner cases, like in a unit-sized array, or when the target element lies on the array boundaries (leftmost/rightmost element).</p> </blockquote> <h4 id="liveness">Liveness:</h4> <ul> <li>The Algorithm must always terminate. This means, for every array, the algorithm must produce an output and exit.</li> </ul> <blockquote> <p>This kind of issue generally manifests itself when the comparision operations within the algorithm fail. For an example, the bounds do not get updated, or there is a stray equality comparision which lets the algorithm run without stopping.</p> </blockquote> <h2 id="filling-in-the-blanks">Filling in the blanks</h2> <p>Let’s start filling in the blanks on the above code.</p> <h3 id="determining-search-starting-bounds-and-loop-invariant">Determining search starting bounds and loop invariant</h3> <p>The first blank decides where the array search starts. It is evident that we want to start searching from the beginning of the array, so it has the value of \(0\). The same can not be said for the high bound, though, because it determines what the loop condition will be. So let’s fill that out first.</p> <p>We know that a binary search converges when the length of the search array becomes unit, i.e. \(1\). This means, the left bound and right bound should coincide (since we are searching in an inclusive array, i.e. \( [low, high] \)). So the algorithm’s loop should run until the bounds coincide, at which point either the element is already found and returned, or the element was not found and the algorithm terminates. So, we have two ways to show non-coinciding bounds: \(loop\ while\ \ (low &lt; high)\) or \(loop\ while\ \ (low \neq high)\)</p> <p>If we opt to go with the second method, i.e. <code class="language-plaintext highlighter-rouge">loop while (left != right)</code>, then, the right bound cannot be set to <code class="language-plaintext highlighter-rouge">len(array) - 1</code>, since in a two-sized array, this will effectively prevent the looping from happening at all. So, the bounds and loop invariants can be determined as:</p> <ol> <li>If <code class="language-plaintext highlighter-rouge">low = 0</code>, <code class="language-plaintext highlighter-rouge">high = len(array)</code>, then the loop invariant to hold is <code class="language-plaintext highlighter-rouge">low &lt; high</code>.</li> <li>If <code class="language-plaintext highlighter-rouge">low = 0</code>, <code class="language-plaintext highlighter-rouge">high = len(array) - 1</code>, then the loop invariant to hold is <code class="language-plaintext highlighter-rouge">low &lt;= high</code>.</li> </ol> <h3 id="determining-the-conditional-check-at-mid">Determining the conditional check at <code class="language-plaintext highlighter-rouge">mid</code>.</h3> <p>Looking at the pseudocode again, we have this segment to fill out:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="bp">...</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">low</span> <span class="o">+</span> <span class="n">high</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">array</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mid</span>
        <span class="k">if</span> <span class="n">array</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="n">__</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">low</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="n">__</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">high</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="n">__</span>
<span class="bp">...</span>
</code></pre></div></div> <p>Which is the inner part of the loop. The first check is to see if <code class="language-plaintext highlighter-rouge">array[mid]</code> meets the target, is smaller, etc. Since we have assumed an array sorted in the ascending order, we update the lower bound <em>only</em> when the middle element is such that the target cannot be in the LHS of the array. This means, target could be either less than, or equal to <code class="language-plaintext highlighter-rouge">array[mid]</code>. However, as we see above, when <code class="language-plaintext highlighter-rouge">array[mid] == target</code>, we have an early return. So the only conditional that can fit is <code class="language-plaintext highlighter-rouge">if array[mid] &lt; target</code>.</p> <h3 id="updating-bounds">Updating bounds</h3> <p>Lastly remaining - to update the bounds. When the middle element of the array is smaller than the target, there is no point starting the low bound again from midpoint, so we update it as <code class="language-plaintext highlighter-rouge">low = mid + 1</code>. However, if it is not smaller than the target, it means, it could be greater than the target, or equal to it. Since we already do an equality comparision with target above it, it would be strictly greater than the target. As such, we can exclude it from search next, so we update <code class="language-plaintext highlighter-rouge">high = mid - 1</code> in the next blank.</p> <h2 id="final-solution">Final solution</h2> <p>This generates the following code finally:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">binarysearch</span> <span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">low</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">low</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="p">:</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">low</span> <span class="o">+</span> <span class="n">high</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">array</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mid</span>
        <span class="k">if</span> <span class="n">array</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">low</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">high</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div></div> <h2 id="proof-of-termination">Proof of termination</h2> <p>We are interested in checking that the algorithm terminates properly. Since we have chosen multiple constants and equality checks above based on one-another, they form a subset of choices that could’ve been made, so we will not check for correctness now.</p> <p>For proof of termination, we will check two scenarios, based on the bounds we chose to go with. They are:</p> <ol> <li><code class="language-plaintext highlighter-rouge">high = len(array) - 1</code> and loop invariant as <code class="language-plaintext highlighter-rouge">low &lt;= high</code></li> <li><code class="language-plaintext highlighter-rouge">high = len(array)</code> and loop invariant as <code class="language-plaintext highlighter-rouge">low &lt; high</code></li> </ol> <p>Now, we look to proving the loop will indeed converge, and for this, we will use proof by contradiction.</p> <h3 id="scenario-1">Scenario #1</h3> <ul> <li>For the loop to continue running forever when <code class="language-plaintext highlighter-rouge">loop until low &lt;= high</code> invariant is upheld, the <code class="language-plaintext highlighter-rouge">low</code> bound should be strictly less than or equal to the <code class="language-plaintext highlighter-rouge">high</code> bound. This means, no matter what happens, <code class="language-plaintext highlighter-rouge">low</code> can never exceed <code class="language-plaintext highlighter-rouge">high</code>.</li> <li>Which means <code class="language-plaintext highlighter-rouge">low = mid + 1</code>, i.e. <code class="language-plaintext highlighter-rouge">low = (low + high) // 2 + 1</code> never exceeds high.</li> <li>When <code class="language-plaintext highlighter-rouge">low == high</code>, however, <code class="language-plaintext highlighter-rouge">low = (low + high) // 2 + 1</code> becomes <code class="language-plaintext highlighter-rouge">low = (high + high) // 2 + 1</code>, i.e. <code class="language-plaintext highlighter-rouge">low = high + 1</code>.</li> <li>This means, in the next iteration, <code class="language-plaintext highlighter-rouge">low = high + 1</code> will violate the loop invariant, and the loop converges.</li> </ul> <h3 id="scenario-2">Scenario #2</h3> <ul> <li>For the loop to continue running forever when <code class="language-plaintext highlighter-rouge">loop until low &lt; high</code> invariant is upheld, the <code class="language-plaintext highlighter-rouge">low</code> bound should never be equal to or greater than the <code class="language-plaintext highlighter-rouge">high</code> bound. The greater condition is already proved above.</li> <li>This means <code class="language-plaintext highlighter-rouge">low</code> can never be equal to <code class="language-plaintext highlighter-rouge">high</code>.</li> <li>In a finally-converging loop with range size = 2, i.e. <code class="language-plaintext highlighter-rouge">low = high - 1</code>, by virtue of integer division flooring the <code class="language-plaintext highlighter-rouge">mid</code> value becomes: <code class="language-plaintext highlighter-rouge">mid = (low + high) // 2</code>, i.e. <code class="language-plaintext highlighter-rouge">mid = (high + high - 1) // 2</code>. Upon adding <code class="language-plaintext highlighter-rouge">1</code> to this in the loop update, <code class="language-plaintext highlighter-rouge">low = mid + 1</code>, it becomes <code class="language-plaintext highlighter-rouge">low = (high + high - 1) // 2 + 1</code>, which becomes equal to <code class="language-plaintext highlighter-rouge">high</code>.</li> <li>This means, in the next iteration, <code class="language-plaintext highlighter-rouge">low == high</code> will violate the loop invariant and the loop converges.</li> </ul> <h2 id="conclusion">Conclusion</h2> <p>This was a longer-than-expected blog post. Please let me know of any errors in the post by raising a issue in the <a href="https://github.com/sandeshbhusal/sandeshbhusal.github.io">github repository for this blog</a>.</p>]]></content><author><name></name></author><category term="algorithms"/><category term="proofs"/><summary type="html"><![CDATA[Refresher Binary search is one of the most trivial and elegant algorithms to understand, and yet, equally easy to get wrong while implementing it. There are a couple of checkpoints, comparisons and constants, which contribute to the running of the algorithm, which can be easily mistaken. In essence, binary search works by partitioning a given array into two halves successively, until a single element (or position) is reached where the target of interest may be. This means, during each run of the algorithm, we have the following choices to make:]]></summary></entry></feed>