<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://sandeshbhusal.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://sandeshbhusal.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-01-02T15:36:04+00:00</updated><id>https://sandeshbhusal.github.io/feed.xml</id><title type="html">Bhusal’s</title><entry><title type="html">Gossip Glomers - Efficient Broadcast</title><link href="https://sandeshbhusal.github.io/blog/2024/gossip-glomers/" rel="alternate" type="text/html" title="Gossip Glomers - Efficient Broadcast"/><published>2024-12-25T00:00:00+00:00</published><updated>2024-12-25T00:00:00+00:00</updated><id>https://sandeshbhusal.github.io/blog/2024/gossip-glomers</id><content type="html" xml:base="https://sandeshbhusal.github.io/blog/2024/gossip-glomers/"><![CDATA[<p><a href="https://fly.io/dist-sys/">Gossip Glomers</a> is a distributed systems challenge created by <a href="https://fly.io">fly.io</a>, where participants are expected to work around a simulating library called <code class="language-plaintext highlighter-rouge">maelstrom</code> that simulates failures and latencies in a distributed system. The library provided works with <code class="language-plaintext highlighter-rouge">go</code>, but being the rustacean that I am, I decided to rewrite the library in Rust, and implement solutions to the challenges. The <a href="">specifications</a> are publicly available (and well-documented) so it was a breeze to go through. In this post, I will only explain the solutions to the challenge upto the <em>efficient broadcast</em> challenge.</p> <h2 id="about-this-post">About this post.</h2> <p>This post is quite code-heavy as I expect the posts in this series to be. The challenge encompasses a lot of concepts in distributed systems, and frankly, squeezing all solutions into a single post will not make any sense. Instead, they will be spread out over posts in this series.</p> <h2 id="setting-up-the-project">Setting up the project</h2> <p>The ‘maelstrom’ binary can be downloaded and it unsurprisingly works right out of the box. For starters, I created the following project structure:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">.</span>
├── Cargo.lock
├── Cargo.toml
├── maelstrom
    ├── maelstrom
    └── ..
└── src
    ├── main.rs
    └── message.rs
</code></pre></div></div> <p>The <code class="language-plaintext highlighter-rouge">main.rs</code> file is responsible to run the entire application, and <code class="language-plaintext highlighter-rouge">message.rs</code> describes the types of messages we support.</p> <p>The <code class="language-plaintext highlighter-rouge">message.rs</code> file has the following contents:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">serde</span><span class="p">::{</span><span class="n">Deserialize</span><span class="p">,</span> <span class="n">Serialize</span><span class="p">};</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Serialize,</span> <span class="nd">Deserialize,</span> <span class="nd">Clone)]</span>
<span class="nd">#[serde(rename_all</span> <span class="nd">=</span> <span class="s">"snake_case"</span><span class="nd">)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Message</span> <span class="p">{</span>
    <span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="n">src</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="n">dest</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="n">body</span><span class="p">:</span> <span class="n">MessageBody</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Serialize,</span> <span class="nd">Deserialize,</span> <span class="nd">Clone)]</span>
<span class="nd">#[serde(tag</span> <span class="nd">=</span> <span class="s">"type"</span><span class="nd">,</span> <span class="nd">rename_all</span> <span class="nd">=</span> <span class="s">"snake_case"</span><span class="nd">)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">MessageBody</span> <span class="p">{</span>
    <span class="n">Echo</span> <span class="p">{</span>
        <span class="n">msg_id</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
        <span class="n">echo</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="n">EchoOk</span> <span class="p">{</span>
        <span class="n">msg_id</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
        <span class="n">in_reply_to</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
        <span class="n">echo</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="n">Init</span> <span class="p">{</span>
        <span class="n">msg_id</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
        <span class="n">node_id</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
        <span class="n">node_ids</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="n">InitOk</span> <span class="p">{</span>
        <span class="n">in_reply_to</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
    <span class="p">},</span>
<span class="p">}</span>
</code></pre></div></div> <p>One thing that I missed in the beginning was to return an <code class="language-plaintext highlighter-rouge">InitOk</code> message (which was outlined in the spec). Since the go library does that automatically, and we are not using go, we need to implement everything from scratch. Using serde makes this whole thing a breeze. The common fields go into <code class="language-plaintext highlighter-rouge">Message</code> struct, and fields specific to each type of message go to <code class="language-plaintext highlighter-rouge">MessageBody</code>. The body is named <code class="language-plaintext highlighter-rouge">type</code> in the incoming json message, and it seamlessly works with the following message for deserialization:</p> <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nl">"src"</span><span class="p">:</span><span class="w"> </span><span class="s2">"n0"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"dest"</span><span class="p">:</span><span class="w"> </span><span class="s2">"n1"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"body"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"echo_ok"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"msg_id"</span><span class="p">:</span><span class="w"> </span><span class="mi">123</span><span class="p">,</span><span class="w">
        </span><span class="nl">"echo"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Echo echo"</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div> <p>The next thing would be to implement methods to read/write from/to stdin/stdout.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">buffer</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">node</span><span class="p">:</span> <span class="n">Node</span> <span class="o">=</span> <span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">();</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="n">buffer</span><span class="nf">.clear</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="nf">stdin</span><span class="p">()</span><span class="nf">.read_line</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">buffer</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="k">if</span> <span class="n">len</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">message</span><span class="p">:</span> <span class="n">Message</span> <span class="o">=</span> <span class="k">match</span> <span class="nn">serde_json</span><span class="p">::</span><span class="nf">from_str</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">msg</span><span class="p">,</span>
            <span class="nf">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"Error parsing message: {}"</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">};</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">=</span> <span class="n">node</span><span class="nf">.handle_message</span><span class="p">(</span><span class="n">message</span><span class="p">)</span> <span class="p">{</span>
            <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"Error handling message: {}"</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div> <p>The node does not need to be concurrent - we process messages serially. The code keeps reading from stdin, creating a message (after deserializing), and passing the deserialized messages to the node. Next, the implementation for <code class="language-plaintext highlighter-rouge">Node</code> type.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Debug,</span> <span class="nd">Default,</span> <span class="nd">Clone)]</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="n">id</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">node_ids</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">current_msg_id</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">id</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">node_ids</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="n">Node</span> <span class="p">{</span>
            <span class="n">id</span><span class="p">,</span>
            <span class="n">node_ids</span><span class="p">,</span>
            <span class="n">current_msg_id</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">get_next_message_id</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">handle_echo</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">echo_in</span><span class="p">:</span> <span class="n">Message</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">handle_message</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="n">Message</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>The <code class="language-plaintext highlighter-rouge">Node</code> struct itself is very simple - it stores the node’s <code class="language-plaintext highlighter-rouge">id</code>, the <code class="language-plaintext highlighter-rouge">node_ids</code> of all nodes in the distributed system, and stores the current message id to use (no need to use atomic ints since we are just processing stuff in a single-thread). Next would be the implementation of each of these handlers. The <code class="language-plaintext highlighter-rouge">get_next_message_id</code> itself is very simple:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">get_next_message_id</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">current_id</span> <span class="o">=</span> <span class="k">self</span><span class="py">.current_msg_id</span><span class="p">;</span>
    <span class="k">self</span><span class="py">.current_msg_id</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">current_id</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="a-very-basic-echo">A very basic echo</h2> <p>In order to handle messages in the Node, we dispatch it to the <code class="language-plaintext highlighter-rouge">handle_message</code> function from our <code class="language-plaintext highlighter-rouge">main</code> function:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">handle_message</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="n">Message</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">match</span> <span class="n">message</span><span class="py">.body</span><span class="nf">.clone</span><span class="p">()</span> <span class="p">{</span>
        <span class="nn">MessageBody</span><span class="p">::</span><span class="n">Echo</span> <span class="p">{</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="k">self</span><span class="nf">.handle_echo</span><span class="p">(</span><span class="n">message</span><span class="p">),</span>
        <span class="nn">MessageBody</span><span class="p">::</span><span class="n">Init</span> <span class="p">{</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">msg_id</span><span class="p">,</span> <span class="n">node_ids</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="c1">// Initialize the node</span>
            <span class="k">self</span><span class="py">.id</span> <span class="o">=</span> <span class="n">node_id</span><span class="p">;</span>
            <span class="k">self</span><span class="py">.node_ids</span> <span class="o">=</span> <span class="n">node_ids</span><span class="p">;</span>

            <span class="c1">// Send init_ok response</span>
            <span class="k">let</span> <span class="n">reply_message</span> <span class="o">=</span> <span class="n">Message</span> <span class="p">{</span>
                <span class="n">src</span><span class="p">:</span> <span class="k">self</span><span class="py">.id</span><span class="nf">.clone</span><span class="p">(),</span>
                <span class="n">dest</span><span class="p">:</span> <span class="n">message</span><span class="nf">.clone</span><span class="p">()</span><span class="py">.src</span><span class="p">,</span>
                <span class="n">body</span><span class="p">:</span> <span class="nn">MessageBody</span><span class="p">::</span><span class="n">InitOk</span> <span class="p">{</span>
                    <span class="n">in_reply_to</span><span class="p">:</span> <span class="n">msg_id</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">};</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nn">serde_json</span><span class="p">::</span><span class="nf">to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reply_message</span><span class="p">)</span><span class="o">?</span><span class="p">);</span>
            <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nn">serde_json</span><span class="p">::</span><span class="nf">to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reply_message</span><span class="p">)</span><span class="o">?</span><span class="p">);</span>

            <span class="nf">Ok</span><span class="p">(())</span>
        <span class="p">}</span>
        <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"Unhandled message type"</span><span class="p">);</span>
            <span class="nf">Ok</span><span class="p">(())</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>The handle_message message is what brings it all together. We check the message type. If it’s the init message, we send a <code class="language-plaintext highlighter-rouge">ok</code> response for init and initialize our node. Otherwise, we dispatch the message to a relevant message handler. As we can see in the case of the <code class="language-plaintext highlighter-rouge">echo</code> message:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">handle_echo</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">echo_in</span><span class="p">:</span> <span class="n">Message</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nn">MessageBody</span><span class="p">::</span><span class="n">Echo</span> <span class="p">{</span> <span class="n">msg_id</span><span class="p">,</span> <span class="n">echo</span> <span class="p">}</span> <span class="o">=</span> <span class="n">echo_in</span><span class="py">.body</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">reply_message</span> <span class="o">=</span> <span class="n">Message</span> <span class="p">{</span>
            <span class="n">src</span><span class="p">:</span> <span class="k">self</span><span class="py">.id</span><span class="nf">.clone</span><span class="p">(),</span>
            <span class="n">dest</span><span class="p">:</span> <span class="n">echo_in</span><span class="py">.src</span><span class="p">,</span>
            <span class="n">body</span><span class="p">:</span> <span class="nn">MessageBody</span><span class="p">::</span><span class="n">EchoOk</span> <span class="p">{</span>
                <span class="n">msg_id</span><span class="p">:</span> <span class="k">self</span><span class="nf">.get_next_message_id</span><span class="p">(),</span>
                <span class="n">in_reply_to</span><span class="p">:</span> <span class="n">msg_id</span><span class="p">,</span>
                <span class="n">echo</span><span class="p">,</span>
            <span class="p">},</span>
        <span class="p">};</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nn">serde_json</span><span class="p">::</span><span class="nf">to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reply_message</span><span class="p">)</span><span class="o">?</span><span class="p">);</span>
        <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nn">serde_json</span><span class="p">::</span><span class="nf">to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reply_message</span><span class="p">)</span><span class="o">?</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div> <p>Even though the message type can never be anything other that <code class="language-plaintext highlighter-rouge">MessageBody::Echo</code>, we still use it to cast the message (I guess this would’ve been better in C++, since we have two vtable lookups, one in handle_message and another in <code class="language-plaintext highlighter-rouge">handle_echo</code>).</p> <p>Testing this with maelstrom library, we can see everything works:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>./maelstrom/maelstrom <span class="nb">test</span> <span class="nt">-w</span> <span class="nb">echo</span> <span class="nt">--bin</span> target/release/gossiprs <span class="se">\</span>
    <span class="nt">--node-count</span> 1 <span class="nt">--time-limit</span> 10

...
... bunch of output
...

Everything looks good! ヽ<span class="o">(</span>‘ー<span class="sb">`</span><span class="o">)</span>ノ
</code></pre></div></div> <h2 id="improving-message-handling">Improving message handling:</h2> <p>Since the first message is always the <code class="language-plaintext highlighter-rouge">init</code> message, we can check to see if that is actually the case, and only process messages after the first one (since we might miss a <code class="language-plaintext highlighter-rouge">init</code> message, and reach an invalid node state).</p> <div class="language-patch highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gh">diff --git a/src/main.rs b/src/main.rs
index 8cb2685..434d943 100644
</span><span class="gd">--- a/src/main.rs
</span><span class="gi">+++ b/src/main.rs
</span><span class="p">@@ -6,6 +6,7 @@</span> use std::io::stdin;
 mod message;
 
 #[derive(Debug, Default, Clone)]
<span class="gi">+#[allow(unused)]
</span> struct Node {
     id: String,
     node_ids: Vec&lt;String&gt;,
<span class="p">@@ -44,27 +45,26 @@</span> impl Node {
         Ok(())
     }
 
<span class="gi">+    fn handle_init(&amp;mut self, msg_id: i32, src: String) -&gt; Result&lt;()&gt; {
+        // Send init_ok response
+        let reply_message = Message {
+            src: self.id.clone(),
+            dest: src,
+            body: MessageBody::InitOk {
+                in_reply_to: msg_id,
+            },
+        };
+        println!("{}", serde_json::to_string(&amp;reply_message)?);
+        eprintln!("{}", serde_json::to_string(&amp;reply_message)?);
+
+        Ok(())
+    }
+
</span>     fn handle_message(&amp;mut self, message: Message) -&gt; Result&lt;()&gt; {
         match message.body.clone() {
             MessageBody::Echo { .. } =&gt; self.handle_echo(message),
<span class="gd">-            MessageBody::Init { node_id, msg_id, node_ids } =&gt; {
-                // Initialize the node
-                self.id = node_id;
-                self.node_ids = node_ids;
-
-                // Send init_ok response
-                let reply_message = Message {
-                    src: self.id.clone(),
-                    dest: message.clone().src,
-                    body: MessageBody::InitOk {
-                        in_reply_to: msg_id,
-                    },
-                };
-                println!("{}", serde_json::to_string(&amp;reply_message)?);
-                eprintln!("{}", serde_json::to_string(&amp;reply_message)?);
</span><span class="gi">+            MessageBody::Init { msg_id, .. } =&gt; self.handle_init(msg_id, message.src.clone()),
</span> 
<span class="gd">-                Ok(())
-            }
</span>             _ =&gt; {
                 eprintln!("Unhandled message type");
                 Ok(())
<span class="p">@@ -76,26 +76,38 @@</span> impl Node {
 #[tokio::main]
 async fn main() -&gt; Result&lt;()&gt; {
     let mut buffer = String::new();
<span class="gd">-    let mut node: Node = Default::default();
</span> 
<span class="gd">-    loop {
-        buffer.clear();
-        let len = stdin().read_line(&amp;mut buffer)?;
-        if len == 0 {
-            break;
-        }
</span><span class="gi">+    stdin().read_line(&amp;mut buffer)?;
+    let message: Message = serde_json::from_str(&amp;buffer)?;
+
+    if let MessageBody::Init {
+        node_id, node_ids, ..
+    } = message.body
+    {
+        let mut node: Node = Node::new(node_id, node_ids);
+        node.handle_message(serde_json::from_str(&amp;buffer)?)?;
</span> 
<span class="gd">-        let message: Message = match serde_json::from_str(&amp;buffer) {
-            Ok(msg) =&gt; msg,
-            Err(e) =&gt; {
-                eprintln!("Error parsing message: {}", e);
-                continue;
</span><span class="gi">+        loop {
+            buffer.clear();
+            let len = stdin().read_line(&amp;mut buffer)?;
+            if len == 0 {
+                break;
</span>             }
<span class="gd">-        };
</span> 
<span class="gd">-        if let Err(e) = node.handle_message(message) {
-            eprintln!("Error handling message: {}", e);
</span><span class="gi">+            let message: Message = match serde_json::from_str(&amp;buffer) {
+                Ok(msg) =&gt; msg,
+                Err(e) =&gt; {
+                    eprintln!("Error parsing message: {}", e);
+                    continue;
+                }
+            };
+
+            if let Err(e) = node.handle_message(message) {
+                eprintln!("Error handling message: {}", e);
+            }
</span>         }
<span class="gi">+    } else {
+        panic!("Expected first messaage to be a init message");
</span>     }
 
     Ok(())
</code></pre></div></div> <h2 id="handling-unique-ids">Handling unique IDs</h2> <p>The next part of the challenge is to handle unique ID generation. For that, we will introduce the required message types to our <code class="language-plaintext highlighter-rouge">Message</code> struct, and store an internal counter in the Node. Also, we improve “responding” by sending out messages on <code class="language-plaintext highlighter-rouge">stdout</code> <em>and</em> logging our progress on <code class="language-plaintext highlighter-rouge">stderr</code>. The majority of the work is done in the <code class="language-plaintext highlighter-rouge">handle_generate</code> function as listed below:</p> <div class="language-patch highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gh">diff --git a/src/main.rs b/src/main.rs
index 434d943..772c545 100644
</span><span class="gd">--- a/src/main.rs
</span><span class="gi">+++ b/src/main.rs
</span><span class="p">@@ -1,14 +1,18 @@</span>
 use anyhow::Result;
 use message::{Message, MessageBody};
 use serde_json;
<span class="gd">-use std::io::stdin;
</span><span class="gi">+use std::{
+    io::{stdin, Write},
+    sync::atomic::AtomicUsize,
+};
</span> 
 mod message;
 
<span class="gd">-#[derive(Debug, Default, Clone)]
</span><span class="gi">+#[derive(Debug)]
</span> #[allow(unused)]
 struct Node {
     id: String,
<span class="gi">+    counter: AtomicUsize,
</span>     node_ids: Vec&lt;String&gt;,
     current_msg_id: i32,
 }
<span class="p">@@ -16,6 +20,7 @@</span> struct Node {
 impl Node {
     fn new(id: String, node_ids: Vec&lt;String&gt;) -&gt; Self {
         Node {
<span class="gi">+            counter: AtomicUsize::new(0),
</span>             id,
             node_ids,
             current_msg_id: 0,
<span class="p">@@ -54,16 +59,45 @@</span> impl Node {
                 in_reply_to: msg_id,
             },
         };
<span class="gd">-        println!("{}", serde_json::to_string(&amp;reply_message)?);
-        eprintln!("{}", serde_json::to_string(&amp;reply_message)?);
</span> 
<span class="gd">-        Ok(())
</span><span class="gi">+        self.write_and_log_response(reply_message)
+    }
+
+    fn handle_generate(&amp;mut self, message: Message) -&gt; Result&lt;()&gt; {
+        // Generate a unique ID and send back to the receiver.
+        // To generate a unique ID, we will take the instant value in self,
+        // and just return the number of millis passed.
+
+        Ok(if let MessageBody::Generate { msg_id } = message.body {
+            let reply_message = Message {
+                src: self.id.clone(),
+                dest: message.src,
+                body: MessageBody::GenerateOk {
+                    id: format!(
+                        "{}-{}",
+                        self.id,
+                        self.counter
+                            .fetch_add(1, std::sync::atomic::Ordering::SeqCst)
+                    ),
+                    msg_id: self.get_next_message_id(),
+                    in_reply_to: msg_id,
+                },
+            };
+
+            self.write_and_log_response(reply_message)?
+        } else {
+            ()
+        })
</span>     }
 
     fn handle_message(&amp;mut self, message: Message) -&gt; Result&lt;()&gt; {
<span class="gi">+        let converted = serde_json::to_string(&amp;message)?;
+        eprintln!("Received request: {}", converted);
+
</span>         match message.body.clone() {
             MessageBody::Echo { .. } =&gt; self.handle_echo(message),
             MessageBody::Init { msg_id, .. } =&gt; self.handle_init(msg_id, message.src.clone()),
<span class="gi">+            MessageBody::Generate { .. } =&gt; self.handle_generate(message),
</span> 
             _ =&gt; {
                 eprintln!("Unhandled message type");
<span class="p">@@ -71,6 +105,13 @@</span> impl Node {
             }
         }
     }
<span class="gi">+
+    fn write_and_log_response(&amp;self, message: Message) -&gt; Result&lt;()&gt; {
+        let converted = serde_json::to_string(&amp;message)?;
+        println!("{}", converted);
+        eprint!("Responding: {}", converted);
+        Ok(std::io::stdout().flush()?)
+    }
</span> }
 
 #[tokio::main]
<span class="gh">diff --git a/src/message.rs b/src/message.rs
index 6c79550..01adec1 100644
</span><span class="gd">--- a/src/message.rs
</span><span class="gi">+++ b/src/message.rs
</span><span class="p">@@ -20,6 +20,7 @@</span> pub enum MessageBody {
         in_reply_to: i32,
         echo: String,
     },
<span class="gi">+
</span>     Init {
         msg_id: i32,
         node_id: String,
<span class="p">@@ -28,4 +29,14 @@</span> pub enum MessageBody {
     InitOk {
         in_reply_to: i32,
     },
<span class="gi">+
+    Generate {
+        msg_id: i32
+    },
+
+    GenerateOk {
+        id: String,
+        msg_id: i32,
+        in_reply_to: i32
+    },
</span> }
</code></pre></div></div> <h2 id="the-fun-begins">The fun begins!</h2> <p>Now the actual fun begins. We will implement methods to handle broadcast, and forward it to our peers.</p> <div class="language-patch highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gh">diff --git a/src/main.rs b/src/main.rs
index 772c545..7b19426 100644
</span><span class="gd">--- a/src/main.rs
</span><span class="gi">+++ b/src/main.rs
</span><span class="p">@@ -2,6 +2,7 @@</span> use anyhow::Result;
 use message::{Message, MessageBody};
 use serde_json;
 use std::{
<span class="gi">+    collections::HashSet,
</span> };
<span class="p">@@ -14,6 +15,7 @@</span> struct Node {
     id: String,
<span class="gi">+    values: HashSet&lt;i32&gt;,
</span>     current_msg_id: i32,
 }
 
<span class="p">@@ -24,6 +26,7 @@</span> impl Node {
             id,
<span class="gi">+            values: HashSet::new(),
</span>         }
     }
<span class="err">
</span><span class="gi">+    fn handle_broadcast(&amp;mut self, message: Message) -&gt; Result&lt;()&gt; {
+        if let MessageBody::Broadcast {
+            msg_id,
+            message: value,
+        } = message.body
+        {
+            self.values.insert(value);
+            let reply = Message {
+                src: self.id.clone(),
+                dest: message.src,
+                body: MessageBody::BroadcastOk {
+                    in_reply_to: msg_id,
+                    msg_id: self.get_next_message_id(),
+                },
+            };
+
+            self.write_and_log_response(reply)
+        } else {
+            Ok(())
+        }
+    }
+
+    fn handle_read(&amp;mut self, message: Message) -&gt; Result&lt;()&gt; {
+        if let MessageBody::Read { msg_id } = message.body {
+            let messages: HashSet&lt;i32&gt; = self.values.clone();
+            let reply = Message {
+                src: self.id.clone(),
+                dest: message.src,
+                body: MessageBody::ReadOk {
+                    messages,
+                    in_reply_to: msg_id,
+                },
+            };
+
+            self.write_and_log_response(reply)
+        } else {
+            Ok(())
+        }
+    }
+
+    fn handle_topology(&amp;mut self, message: Message) -&gt; Result&lt;()&gt; {
+        if let MessageBody::Topology { msg_id, .. } = message.body {
+            let reply = Message {
+                src: self.id.clone(),
+                dest: message.src,
+                body: MessageBody::TopologyOk {
+                    in_reply_to: msg_id,
+                },
+            };
+
+            self.write_and_log_response(reply)
+        } else {
+            Ok(())
+        }
+    }
+
</span>     fn handle_message(&amp;mut self, message: Message) -&gt; Result&lt;()&gt; {
         let converted = serde_json::to_string(&amp;message)?;
         eprintln!("Received request: {}", converted);
<span class="p">@@ -98,6 +157,9 @@</span> impl Node {
             MessageBody::Echo { .. } =&gt; self.handle_echo(message),
<span class="gi">+            MessageBody::Broadcast { .. } =&gt; self.handle_broadcast(message),
+            MessageBody::Read { .. } =&gt; self.handle_read(message),
+            MessageBody::Topology { .. } =&gt; self.handle_topology(message),
</span> 
             _ =&gt; {
                 eprintln!("Unhandled message type");
<span class="gh">diff --git a/src/message.rs b/src/message.rs
index 01adec1..7dd52b7 100644
</span><span class="gd">--- a/src/message.rs
</span><span class="gi">+++ b/src/message.rs
</span><span class="p">@@ -1,3 +1,5 @@</span>
<span class="gi">+use std::collections::{HashMap, HashSet};
+
</span> #[derive(Debug, Serialize, Deserialize, Clone)]
<span class="p">@@ -39,4 +41,32 @@</span> pub enum MessageBody {
<span class="gi">+    Broadcast {
+        msg_id: i32,
+        message: i32
+    },
+
+    BroadcastOk {
+        in_reply_to: i32,
+        msg_id: i32
+    },
+
+    Read {
+        msg_id: i32,
+    },
+
+    ReadOk {
+        messages: HashSet&lt;i32&gt;,
+        in_reply_to: i32
+    },
+
+    Topology {
+        msg_id: i32,
+        topology: HashMap&lt;String, Vec&lt;String&gt;&gt;
+    },
+
+    TopologyOk {
+        in_reply_to: i32
+    }
</span> }
</code></pre></div></div> <p>For this, we need to implement handlers for <code class="language-plaintext highlighter-rouge">read</code>, <code class="language-plaintext highlighter-rouge">topology</code>, and <code class="language-plaintext highlighter-rouge">broadcast</code> messages as listed in the outline. The logic itself is super simple; we store all the IDs we’ve seen in a <code class="language-plaintext highlighter-rouge">HashSet</code>, and return the hashset when <code class="language-plaintext highlighter-rouge">read</code> is invoked on our node.</p> <h2 id="talking-to-other-nodes">Talking to other nodes</h2> <p>The next patch will implement a way to talk to other nodes, whatever is connected to ours.</p> <div class="language-patch highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gh">diff --git a/src/main.rs b/src/main.rs
index 7b19426..0f955b8 100644
</span><span class="gd">--- a/src/main.rs
</span><span class="gi">+++ b/src/main.rs
</span><span class="p">@@ -17,6 +17,8 @@</span> struct Node {
     node_ids: Vec&lt;String&gt;,
     values: HashSet&lt;i32&gt;,
     current_msg_id: i32,
<span class="gi">+    neighbors: Vec&lt;String&gt;,
+    downstream: Vec&lt;String&gt;,
</span> }
 
 impl Node {
<span class="p">@@ -27,6 +29,8 @@</span> impl Node {
             node_ids,
             current_msg_id: 0,
             values: HashSet::new(),
<span class="gi">+            neighbors: Vec::new(),
+            downstream: Vec::new(),
</span>         }
     }
 
<span class="p">@@ -99,7 +103,7 @@</span> impl Node {
             message: value,
         } = message.body
         {
<span class="gd">-            self.values.insert(value);
</span><span class="gi">+            // First, respond that I got this value.
</span>             let reply = Message {
                 src: self.id.clone(),
                 dest: message.src,
<span class="p">@@ -109,7 +113,65 @@</span> impl Node {
                 },
             };
 
<span class="gd">-            self.write_and_log_response(reply)
</span><span class="gi">+            self.write_and_log_response(reply)?;
+
+            let i_have_this = self.values.contains(&amp;value);
+            if !i_have_this {
+                self.values.insert(value);
+
+                // Tell my friends about this too!. Write Gossip messages.
+                let neighbors = self.neighbors.clone();
+                for neighbor in neighbors {
+                    let new_msg_id = self.get_next_message_id();
+
+                    let gossip = Message {
+                        src: self.id.clone(),
+                        dest: neighbor.clone(),
+                        body: MessageBody::Gossip {
+                            msg_id: new_msg_id,
+                            gossip_value: value,
+                        },
+                    };
+
+                    self.write_and_log_response(gossip)?;
+                }
+            }
+
+            Ok(())
+        } else {
+            Ok(())
+        }
+    }
+
+    fn handle_gossip(&amp;mut self, message: Message) -&gt; Result&lt;()&gt; {
+        if let MessageBody::Gossip {
+            gossip_value: value,
+            ..
+        } = message.body
+        {
+            let i_have_this = self.values.contains(&amp;value);
+            if !i_have_this {
+                self.values.insert(value);
+
+                // Tell my friends about this too!. Write Gossip messages.
+                let neighbors = self.neighbors.clone();
+                for neighbor in neighbors {
+                    let new_msg_id = self.get_next_message_id();
+
+                    let gossip = Message {
+                        src: self.id.clone(),
+                        dest: neighbor.clone(),
+                        body: MessageBody::Gossip {
+                            msg_id: new_msg_id,
+                            gossip_value: value,
+                        },
+                    };
+
+                    self.write_and_log_response(gossip)?;
+                }
+            }
+
+            Ok(())
</span>         } else {
             Ok(())
         }
<span class="p">@@ -134,7 +196,21 @@</span> impl Node {
     }
 
     fn handle_topology(&amp;mut self, message: Message) -&gt; Result&lt;()&gt; {
<span class="gd">-        if let MessageBody::Topology { msg_id, .. } = message.body {
</span><span class="gi">+        if let MessageBody::Topology {
+            msg_id,
+            topology: graph,
+        } = message.body
+        {
+            self.neighbors = graph
+                .get(&amp;self.id)
+                .expect("No neighbors defined for me? Empty??")
+                .clone();
+
+            // Something fancy. Do some graph computation to find downstream nodes? Nah.
+            // Maybe in 3.d.
+
+            self.downstream.extend(self.neighbors.clone());
+
</span>             let reply = Message {
                 src: self.id.clone(),
                 dest: message.src,
<span class="p">@@ -160,6 +236,7 @@</span> impl Node {
             MessageBody::Broadcast { .. } =&gt; self.handle_broadcast(message),
             MessageBody::Read { .. } =&gt; self.handle_read(message),
             MessageBody::Topology { .. } =&gt; self.handle_topology(message),
<span class="gi">+            MessageBody::Gossip { .. } =&gt; self.handle_gossip(message),
</span> 
             _ =&gt; {
                 eprintln!("Unhandled message type");
<span class="gh">diff --git a/src/message.rs b/src/message.rs
index 7dd52b7..1748ee8 100644
</span><span class="gd">--- a/src/message.rs
</span><span class="gi">+++ b/src/message.rs
</span><span class="p">@@ -68,5 +68,12 @@</span> pub enum MessageBody {
 
     TopologyOk {
         in_reply_to: i32
<span class="gd">-    }
</span><span class="gi">+    },
+
+    // Custom message types:
+
+    Gossip {
+        msg_id: i32,
+        gossip_value: i32
+    },
</span> }
</code></pre></div></div> <p>The logic is simple:</p> <ul> <li>We <code class="language-plaintext highlighter-rouge">Gossip</code> our message to our peers when we receive a gossip message. Before doing that, we acknowledge the gossip.</li> <li>The <code class="language-plaintext highlighter-rouge">GossipAck</code> message is sent to the sender to make sure they don’t re-send the gossip again (this comes in a later part).</li> </ul> <p>If we do not respond before updating our state, we will fall into an infinite loop where we forward the message, receive it, and keep forwarding it. So, we first ack the message, and <em>then</em> forward it to the neighbors.</p> <h2 id="sending-message-with-retries">Sending message with Retries</h2> <p>The current method implements ways to send message, but we do not retry if it fails. Since we don’t have the privilege of using <code class="language-plaintext highlighter-rouge">SyncRPC</code> that is in the go library, we need to implement our own. The go library uses <code class="language-plaintext highlighter-rouge">Context</code> with <code class="language-plaintext highlighter-rouge">Cancel</code>, and something similar that can be implemented in Rust is a <code class="language-plaintext highlighter-rouge">oneshot_channel</code>. For every message we expect to receive a reply to, we store a <code class="language-plaintext highlighter-rouge">oneshot</code> channel, which is keyed on the message id. If we receive any message whose <code class="language-plaintext highlighter-rouge">in_reply_to</code> field has that particular message id, we pop the channel, and cancel our timeout.</p> <div class="language-patch highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gh">diff --git a/src/main.rs b/src/main.rs
index 0f955b8..b61487b 100644
</span><span class="gd">--- a/src/main.rs
</span><span class="gi">+++ b/src/main.rs
</span><span class="p">@@ -2,10 +2,12 @@</span> use anyhow::Result;
 use message::{Message, MessageBody};
 use serde_json;
 use std::{
<span class="gd">-    collections::HashSet,
</span><span class="gi">+    collections::{HashMap, HashSet},
</span>     io::{stdin, Write},
     sync::atomic::AtomicUsize,
<span class="gi">+    time::Duration,
</span> };
<span class="gi">+use tokio::{runtime::Runtime, time};
</span> 
 mod message;
 
<span class="p">@@ -13,24 +15,28 @@</span> mod message;
 #[allow(unused)]
 struct Node {
     id: String,
<span class="gi">+    runtime: Runtime,
</span>     counter: AtomicUsize,
     node_ids: Vec&lt;String&gt;,
     values: HashSet&lt;i32&gt;,
     current_msg_id: i32,
     neighbors: Vec&lt;String&gt;,
     downstream: Vec&lt;String&gt;,
<span class="gi">+    ack_channels: HashMap&lt;i32, tokio::sync::oneshot::Sender&lt;i32&gt;&gt;,
</span> }
 
 impl Node {
     fn new(id: String, node_ids: Vec&lt;String&gt;) -&gt; Self {
         Node {
             counter: AtomicUsize::new(0),
<span class="gi">+            runtime: Runtime::new().unwrap(),
</span>             id,
             node_ids,
             current_msg_id: 0,
             values: HashSet::new(),
             neighbors: Vec::new(),
             downstream: Vec::new(),
<span class="gi">+            ack_channels: HashMap::new(),
</span>         }
     }
 
<span class="p">@@ -51,8 +57,8 @@</span> impl Node {
                     echo,
                 },
             };
<span class="gd">-            println!("{}", serde_json::to_string(&amp;reply_message)?);
-            eprintln!("{}", serde_json::to_string(&amp;reply_message)?);
</span><span class="gi">+
+            self.write_and_log_response(reply_message)?;
</span>         }
         Ok(())
     }
<span class="p">@@ -238,6 +244,19 @@</span> impl Node {
             MessageBody::Topology { .. } =&gt; self.handle_topology(message),
             MessageBody::Gossip { .. } =&gt; self.handle_gossip(message),
 
<span class="gi">+            MessageBody::GossipAck {
+                in_reply_to,
+                msg_id,
+            } =&gt; {
+                // Check that we have the channel to send the ack.
+                if let Some(sender) = self.ack_channels.remove(&amp;in_reply_to) {
+                    Ok(sender.send(msg_id).unwrap())
+                } else {
+                    eprintln!("No channel found to send ack");
+                    Ok(())
+                }
+            }
+
</span>             _ =&gt; {
                 eprintln!("Unhandled message type");
                 Ok(())
<span class="p">@@ -245,11 +264,39 @@</span> impl Node {
         }
     }
 
<span class="gd">-    fn write_and_log_response(&amp;self, message: Message) -&gt; Result&lt;()&gt; {
-        let converted = serde_json::to_string(&amp;message)?;
-        println!("{}", converted);
-        eprint!("Responding: {}", converted);
-        Ok(std::io::stdout().flush()?)
</span><span class="gi">+    fn write_and_log_response(&amp;mut self, message: Message) -&gt; Result&lt;()&gt; {
+        if let MessageBody::Gossip { msg_id, .. } = &amp;message.body {
+            let (sender, mut receiver) = tokio::sync::oneshot::channel::&lt;i32&gt;();
+            self.ack_channels.insert(*msg_id, sender);
+
+            // Try to send the message to the receiver, wait for a certain time, and send the message
+            // again if we do not get the response back. Do all this within a tokio runtime.
+            let fut = async move {
+                let converted = serde_json::to_string(&amp;message).unwrap();
+                println!("{}", converted);
+                let mut ticker = time::interval(Duration::from_millis(100));
+
+                loop {
+                    tokio::select! {
+                        _ = ticker.tick() =&gt; {
+                            // Resend the message; we have no acks yet.
+                            println!("{}", converted.clone());
+                        }
+                        _ = &amp;mut receiver =&gt; {
+                            // We got an ack! Break the loop.
+                            break
+                        }
+                    }
+                }
+            };
+
+            self.runtime.spawn(fut);
+            Ok(())
+        } else {
+            println!("{}", serde_json::to_string(&amp;message)?);
+            eprint!("Responding: {}", serde_json::to_string(&amp;message)?);
+            Ok(std::io::stdout().flush()?)
+        }
</span>     }
 }
 
<span class="gh">diff --git a/src/message.rs b/src/message.rs
index 1748ee8..d331470 100644
</span><span class="gd">--- a/src/message.rs
</span><span class="gi">+++ b/src/message.rs
</span><span class="p">@@ -76,4 +76,9 @@</span> pub enum MessageBody {
         msg_id: i32,
         gossip_value: i32
     },
<span class="gi">+
+    GossipAck {
+        in_reply_to: i32,
+        msg_id: i32
+    }
</span> }
</code></pre></div></div> <p>In order to implement this, we create a <code class="language-plaintext highlighter-rouge">Tokio</code> runtime, and push futures that are polling the stdin, looking for messages we have replies to, or waiting on a timer, which fires every 100ms. Either the message reply arrives, or the timer expires, when we resend the message. Since we are only looking for replies (confirmation) to the Gossip messages, we match the message type on message send. The future is created only if the message type matches Gossip message. The modification to handling gossip is simple enough:</p> <div class="language-patch highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gh">diff --git a/src/main.rs b/src/main.rs
index b61487b..ab1b253 100644
</span><span class="gd">--- a/src/main.rs
</span><span class="gi">+++ b/src/main.rs
</span><span class="p">@@ -152,9 +152,21 @@</span> impl Node {
     fn handle_gossip(&amp;mut self, message: Message) -&gt; Result&lt;()&gt; {
         if let MessageBody::Gossip {
             gossip_value: value,
<span class="gd">-            ..
</span><span class="gi">+            msg_id
</span>         } = message.body
         {
<span class="gi">+            // First, respond that I got this value.
+            let reply = Message {
+                src: self.id.clone(),
+                dest: message.src,
+                body: MessageBody::GossipAck {
+                    in_reply_to: msg_id,
+                    msg_id: self.get_next_message_id(),
+                },
+            };
+
+            self.write_and_log_response(reply)?;
+
</span>             let i_have_this = self.values.contains(&amp;value);
             if !i_have_this {
                 self.values.insert(value);
</code></pre></div></div> <h2 id="latency-constraints">Latency constraints.</h2> <p>This is the part I had the most fun with while completing the first part of this challenge. You are supposed to send messages with 400ms latency medians (600ms max latency). The constraints are:</p> <ul> <li>30 message-per-op</li> <li>400ms median latency</li> <li>600ms max latency</li> </ul> <p>given that every message has 100ms latency within the system. This means, we need to optimize our graph in some way. In a overkill fashion, I decided to write a genetic algorithm to generate the graph.</p> <h3 id="genetic-algorithm-for-graph-generation">Genetic Algorithm for graph generation.</h3> <p>The graph will be encoded in the following way:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">random</span>
<span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Self</span>
<span class="kn">import</span> <span class="n">networkx</span> <span class="k">as</span> <span class="n">nx</span>
<span class="kn">import</span> <span class="n">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="n">NUM_NODES_FIXED</span> <span class="o">=</span> <span class="mi">25</span>
<span class="n">POPULATION_SIZE</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">MAX_ITERATIONS</span>  <span class="o">=</span> <span class="mi">500</span>
<span class="n">MAX_PERMISSIBLE_PATH_LENGTH</span> <span class="o">=</span> <span class="mi">6</span>

<span class="k">class</span> <span class="nc">Graph</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">num_nodes</span> <span class="o">=</span> <span class="mi">25</span><span class="p">,</span> <span class="n">max_permissible_path_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">self</span><span class="p">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_nodes</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">max_permissible_path_length</span> <span class="o">=</span> <span class="n">max_permissible_path_length</span>
        <span class="n">self</span><span class="p">.</span><span class="n">edges</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">from_vertex</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">to_vertex</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="nf">if </span><span class="p">(</span><span class="n">from_vertex</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">vertices</span> <span class="ow">or</span> <span class="n">to_vertex</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">vertices</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">self</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">from_vertex</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">edges</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">from_vertex</span><span class="p">,</span> <span class="p">[])</span> <span class="ow">or</span> <span class="p">[]</span>
        <span class="n">self</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">to_vertex</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">edges</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">to_vertex</span><span class="p">,</span> <span class="p">[])</span> <span class="ow">or</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">to_vertex</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">from_vertex</span><span class="p">]:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">from_vertex</span><span class="p">].</span><span class="nf">append</span><span class="p">(</span><span class="n">to_vertex</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">to_vertex</span><span class="p">].</span><span class="nf">append</span><span class="p">(</span><span class="n">from_vertex</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_distances</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">from_vertex</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nf">set</span><span class="p">()</span>

        <span class="n">queue</span> <span class="o">=</span> <span class="p">[(</span><span class="n">from_vertex</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
        <span class="n">distances</span><span class="p">[</span><span class="n">from_vertex</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">visited</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">from_vertex</span><span class="p">)</span>

        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">first</span><span class="p">,</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">edges</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="p">[])</span>
            <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                    <span class="n">visited</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">neighbor</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="n">distances</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">=</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">distances</span>

    <span class="k">def</span> <span class="nf">get_nodes_count</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">vertices</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">check_average_propagation_cost</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="n">score</span> <span class="o">=</span> <span class="mi">0</span>
         
        <span class="n">disconnected_nodes</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">nodes_with_maxpath_violations</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">max_edges</span> <span class="o">=</span> <span class="nf">max </span><span class="p">([</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">edges</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="p">[]))</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">vertices</span> <span class="p">])</span>
        <span class="n">total_edges</span> <span class="o">=</span> <span class="nf">sum</span><span class="p">([</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">edges</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="p">[]))</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">vertices</span> <span class="p">])</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">vertices</span><span class="p">:</span>
            <span class="n">distances</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">get_distances</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">disconnected_nodes</span> <span class="o">+=</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">vertices</span><span class="p">)</span> <span class="o">-</span> <span class="nf">len</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span> <span class="c1"># Calculate the number of nodes unreachable from this
</span>            <span class="n">nodes_with_maxpath_violations</span> <span class="o">+=</span> <span class="nf">len</span><span class="p">([</span><span class="n">tonode</span> <span class="k">for</span> <span class="n">tonode</span> <span class="ow">in</span> <span class="n">distances</span> <span class="k">if</span> <span class="n">distances</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">tonode</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">MAX_PERMISSIBLE_PATH_LENGTH</span> <span class="p">])</span>

        <span class="n">score</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">100000</span> <span class="o">*</span> <span class="n">disconnected_nodes</span> <span class="c1"># All nodes MUST be connected
</span>        <span class="n">score</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">100000</span> <span class="o">*</span> <span class="n">nodes_with_maxpath_violations</span>
        <span class="n">score</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">2000</span> <span class="o">*</span> <span class="n">max_edges</span>
        <span class="n">score</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">250</span> <span class="o">*</span> <span class="n">total_edges</span>

        <span class="k">return</span> <span class="n">score</span>
</code></pre></div></div> <p>The functions are pretty self-explanatory:</p> <ul> <li><code class="language-plaintext highlighter-rouge">get_nodes_count</code> returns the number of nodes in the graph.</li> <li><code class="language-plaintext highlighter-rouge">check_average_propagation_cost</code> returns the score of the graph. The score is calculated as: <ul> <li>100000 * disconnected_nodes: All nodes must be connected.</li> <li>100000 * nodes_with_maxpath_violations: No node should have a path length greater than 6.</li> <li>2000 * max_edges: The maximum number of edges in the graph.</li> <li>250 * total_edges: The total number of edges in the graph.</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">get_distances</code> returns the distances from a node to all other nodes in the graph.</li> <li><code class="language-plaintext highlighter-rouge">add_edge</code> adds an edge between two nodes. The edges are bidirectional.</li> <li><code class="language-plaintext highlighter-rouge">__init__</code> initializes the graph.</li> </ul> <p>Using this, and implementing a simple genetic algorithm, we land with a graph that looks like this:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">"n17"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n19"</span><span class="p">,</span> <span class="s">"n0"</span><span class="p">],</span>
<span class="s">"n19"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n17"</span><span class="p">,</span> <span class="s">"n14"</span><span class="p">],</span>
<span class="s">"n10"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n2"</span><span class="p">,</span> <span class="s">"n22"</span><span class="p">,</span> <span class="s">"n20"</span><span class="p">],</span>
<span class="s">"n2"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n10"</span><span class="p">,</span> <span class="s">"n13"</span><span class="p">,</span> <span class="s">"n11"</span><span class="p">],</span>
<span class="s">"n13"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n2"</span><span class="p">,</span> <span class="s">"n15"</span><span class="p">],</span>
<span class="s">"n7"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n14"</span><span class="p">,</span> <span class="s">"n3"</span><span class="p">],</span>
<span class="s">"n14"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n7"</span><span class="p">,</span> <span class="s">"n19"</span><span class="p">,</span> <span class="s">"n12"</span><span class="p">],</span>
<span class="s">"n24"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n22"</span><span class="p">,</span> <span class="s">"n1"</span><span class="p">,</span> <span class="s">"n23"</span><span class="p">],</span>
<span class="s">"n22"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n24"</span><span class="p">,</span> <span class="s">"n10"</span><span class="p">,</span> <span class="s">"n8"</span><span class="p">],</span>
<span class="s">"n18"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n5"</span><span class="p">,</span> <span class="s">"n15"</span><span class="p">],</span>
<span class="s">"n5"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n18"</span><span class="p">,</span> <span class="s">"n0"</span><span class="p">,</span> <span class="s">"n3"</span><span class="p">],</span>
<span class="s">"n0"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n4"</span><span class="p">,</span> <span class="s">"n17"</span><span class="p">,</span> <span class="s">"n5"</span><span class="p">],</span>
<span class="s">"n4"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n0"</span><span class="p">,</span> <span class="s">"n8"</span><span class="p">],</span>
<span class="s">"n1"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n24"</span><span class="p">,</span> <span class="s">"n6"</span><span class="p">,</span> <span class="s">"n11"</span><span class="p">],</span>
<span class="s">"n23"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n24"</span><span class="p">,</span> <span class="s">"n6"</span><span class="p">,</span> <span class="s">"n16"</span><span class="p">],</span>
<span class="s">"n21"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n20"</span><span class="p">,</span> <span class="s">"n12"</span><span class="p">,</span> <span class="s">"n9"</span><span class="p">],</span>
<span class="s">"n20"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n21"</span><span class="p">,</span> <span class="s">"n9"</span><span class="p">,</span> <span class="s">"n10"</span><span class="p">],</span>
<span class="s">"n15"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n13"</span><span class="p">,</span> <span class="s">"n12"</span><span class="p">,</span> <span class="s">"n18"</span><span class="p">],</span>
<span class="s">"n6"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n1"</span><span class="p">,</span> <span class="s">"n23"</span><span class="p">,</span> <span class="s">"n3"</span><span class="p">],</span>
<span class="s">"n12"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n21"</span><span class="p">,</span> <span class="s">"n14"</span><span class="p">,</span> <span class="s">"n15"</span><span class="p">],</span>
<span class="s">"n9"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n21"</span><span class="p">,</span> <span class="s">"n20"</span><span class="p">],</span>
<span class="s">"n11"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n2"</span><span class="p">,</span> <span class="s">"n1"</span><span class="p">],</span>
<span class="s">"n3"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n7"</span><span class="p">,</span> <span class="s">"n6"</span><span class="p">,</span> <span class="s">"n5"</span><span class="p">],</span>
<span class="s">"n8"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n4"</span><span class="p">,</span> <span class="s">"n16"</span><span class="p">,</span> <span class="s">"n22"</span><span class="p">],</span>
<span class="s">"n16"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n23"</span><span class="p">,</span> <span class="s">"n8"</span><span class="p">],</span>

</code></pre></div></div> <p>Instead of using the given topology, this is the topology we can use. With this, we get the following results on median:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>latencies:
0.5<span class="o">=</span>434, 1:599

msg-per-op:
29
</code></pre></div></div> <p>The genetic algorithm is as follows:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Chromosome</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">self</span><span class="p">.</span><span class="n">graph</span> <span class="o">=</span> <span class="nc">Graph</span><span class="p">(</span><span class="n">num_nodes</span><span class="o">=</span><span class="n">NUM_NODES_FIXED</span><span class="p">,</span> <span class="n">max_permissible_path_length</span><span class="o">=</span><span class="n">MAX_PERMISSIBLE_PATH_LENGTH</span><span class="p">)</span>
        <span class="c1"># Initialize some random connections
</span>        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">50</span><span class="p">)):</span>
            <span class="n">from_node</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">NUM_NODES_FIXED</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">to_node</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">NUM_NODES_FIXED</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">from_node</span> <span class="o">!=</span> <span class="n">to_node</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">add_edge</span><span class="p">(</span><span class="n">from_node</span><span class="p">,</span> <span class="n">to_node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">mutate</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
        <span class="sh">"""</span><span class="s">
        Mutation strategies:
        1. Add a random edge
        2. Remove a random edge
        3. Rewire an existing edge
        </span><span class="sh">"""</span>
        <span class="n">mutation_type</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">choice</span><span class="p">([</span><span class="sh">'</span><span class="s">add</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">remove</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">rewire</span><span class="sh">'</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">mutation_type</span> <span class="o">==</span> <span class="sh">'</span><span class="s">add</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">from_node</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">NUM_NODES_FIXED</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">to_node</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">NUM_NODES_FIXED</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">from_node</span> <span class="o">!=</span> <span class="n">to_node</span> <span class="ow">and</span> <span class="n">to_node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">from_node</span><span class="p">,</span> <span class="p">[]):</span>
                <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">add_edge</span><span class="p">(</span><span class="n">from_node</span><span class="p">,</span> <span class="n">to_node</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">mutation_type</span> <span class="o">==</span> <span class="sh">'</span><span class="s">remove</span><span class="sh">'</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">:</span>
                <span class="n">from_node</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">choice</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">.</span><span class="nf">keys</span><span class="p">()))</span>
                <span class="n">to_node</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">choice</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">from_node</span><span class="p">])</span>
                <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">from_node</span><span class="p">].</span><span class="nf">remove</span><span class="p">(</span><span class="n">to_node</span><span class="p">)</span>
                <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">to_node</span><span class="p">].</span><span class="nf">remove</span><span class="p">(</span><span class="n">from_node</span><span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">from_node</span><span class="p">]:</span>
                    <span class="k">del</span> <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">from_node</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">to_node</span><span class="p">]:</span>
                    <span class="k">del</span> <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">to_node</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">mutation_type</span> <span class="o">==</span> <span class="sh">'</span><span class="s">rewire</span><span class="sh">'</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">:</span>
                <span class="n">from_node</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">choice</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">.</span><span class="nf">keys</span><span class="p">()))</span>
                <span class="n">old_to_node</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">choice</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">from_node</span><span class="p">])</span>
                <span class="n">new_to_node</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">NUM_NODES_FIXED</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

                <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">from_node</span><span class="p">].</span><span class="nf">remove</span><span class="p">(</span><span class="n">old_to_node</span><span class="p">)</span>
                <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">old_to_node</span><span class="p">].</span><span class="nf">remove</span><span class="p">(</span><span class="n">from_node</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">new_to_node</span> <span class="o">!=</span> <span class="n">from_node</span> <span class="ow">and</span> <span class="n">new_to_node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">from_node</span><span class="p">,</span> <span class="p">[]):</span>
                    <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">add_edge</span><span class="p">(</span><span class="n">from_node</span><span class="p">,</span> <span class="n">new_to_node</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">self</span>

    <span class="k">def</span> <span class="nf">crossover</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="sh">"</span><span class="s">Chromosome</span><span class="sh">"</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="sh">"</span><span class="s">Chromosome</span><span class="sh">"</span><span class="p">]:</span>
        <span class="sh">"""</span><span class="s">
        Crossover strategies:
        1. Randomly combine edges from both parent chromosomes
        2. Create two offspring with mixed edge sets
        </span><span class="sh">"""</span>
        <span class="n">offspring1</span> <span class="o">=</span> <span class="nc">Chromosome</span><span class="p">()</span>
        <span class="n">offspring2</span> <span class="o">=</span> <span class="nc">Chromosome</span><span class="p">()</span>

        <span class="n">all_edges_parent1</span> <span class="o">=</span> <span class="nf">set</span><span class="p">()</span>
        <span class="n">all_edges_parent2</span> <span class="o">=</span> <span class="nf">set</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">from_node</span><span class="p">,</span> <span class="n">to_nodes</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">.</span><span class="nf">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">to_node</span> <span class="ow">in</span> <span class="n">to_nodes</span><span class="p">:</span>
                <span class="n">all_edges_parent1</span><span class="p">.</span><span class="nf">add</span><span class="p">((</span><span class="n">from_node</span><span class="p">,</span> <span class="n">to_node</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">from_node</span><span class="p">,</span> <span class="n">to_nodes</span> <span class="ow">in</span> <span class="n">other</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">.</span><span class="nf">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">to_node</span> <span class="ow">in</span> <span class="n">to_nodes</span><span class="p">:</span>
                <span class="n">all_edges_parent2</span><span class="p">.</span><span class="nf">add</span><span class="p">((</span><span class="n">from_node</span><span class="p">,</span> <span class="n">to_node</span><span class="p">))</span>

        <span class="n">combined_edges</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="n">all_edges_parent1</span><span class="p">.</span><span class="nf">union</span><span class="p">(</span><span class="n">all_edges_parent2</span><span class="p">))</span>
        <span class="n">random</span><span class="p">.</span><span class="nf">shuffle</span><span class="p">(</span><span class="n">combined_edges</span><span class="p">)</span>

        <span class="n">offspring1_edges</span> <span class="o">=</span> <span class="n">combined_edges</span><span class="p">[:</span><span class="nf">len</span><span class="p">(</span><span class="n">combined_edges</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">offspring2_edges</span> <span class="o">=</span> <span class="n">combined_edges</span><span class="p">[</span><span class="nf">len</span><span class="p">(</span><span class="n">combined_edges</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">:]</span>

        <span class="n">offspring1</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">offspring2</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">from_node</span><span class="p">,</span> <span class="n">to_node</span> <span class="ow">in</span> <span class="n">offspring1_edges</span><span class="p">:</span>
            <span class="n">offspring1</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">add_edge</span><span class="p">(</span><span class="n">from_node</span><span class="p">,</span> <span class="n">to_node</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">from_node</span><span class="p">,</span> <span class="n">to_node</span> <span class="ow">in</span> <span class="n">offspring2_edges</span><span class="p">:</span>
            <span class="n">offspring2</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">add_edge</span><span class="p">(</span><span class="n">from_node</span><span class="p">,</span> <span class="n">to_node</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">offspring1</span><span class="p">,</span> <span class="n">offspring2</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">genetic_algorithm</span><span class="p">():</span>
    <span class="c1"># Initialize population
</span>    <span class="n">population</span> <span class="o">=</span> <span class="p">[</span><span class="nc">Chromosome</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">POPULATION_SIZE</span><span class="p">)]</span>

    <span class="n">best_fitness_history</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Genetic Algorithm main loop
</span>    <span class="k">for</span> <span class="n">generation</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">MAX_ITERATIONS</span><span class="p">):</span>
        <span class="c1"># Evaluate fitness for each chromosome
</span>        <span class="n">fitness_scores</span> <span class="o">=</span> <span class="p">[</span><span class="n">chromosome</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">check_average_propagation_cost</span><span class="p">()</span> <span class="k">for</span> <span class="n">chromosome</span> <span class="ow">in</span> <span class="n">population</span><span class="p">]</span>

        <span class="c1"># Track best fitness in this generation
</span>        <span class="n">best_fitness</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">fitness_scores</span><span class="p">)</span>
        <span class="n">best_fitness_history</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">best_fitness</span><span class="p">)</span>

        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Generation </span><span class="si">{</span><span class="n">generation</span><span class="si">}</span><span class="s">: Best Fitness = </span><span class="si">{</span><span class="n">best_fitness</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

        <span class="c1"># Select top 20% chromosomes for reproduction
</span>        <span class="n">sorted_population</span> <span class="o">=</span> <span class="nf">sorted</span><span class="p">(</span><span class="nf">zip</span><span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="n">fitness_scores</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">top_population</span> <span class="o">=</span> <span class="p">[</span><span class="n">chrom</span> <span class="k">for</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">sorted_population</span><span class="p">[:</span><span class="n">POPULATION_SIZE</span><span class="o">//</span><span class="mi">5</span><span class="p">]]</span>

        <span class="c1"># Create new population through crossover and mutation
</span>        <span class="n">new_population</span> <span class="o">=</span> <span class="n">top_population</span><span class="p">.</span><span class="nf">copy</span><span class="p">()</span>

        <span class="k">while</span> <span class="nf">len</span><span class="p">(</span><span class="n">new_population</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">POPULATION_SIZE</span><span class="p">:</span>
            <span class="c1"># Select parents for crossover
</span>            <span class="n">parent1</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">choice</span><span class="p">(</span><span class="n">top_population</span><span class="p">)</span>
            <span class="n">parent2</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">choice</span><span class="p">(</span><span class="n">top_population</span><span class="p">)</span>

            <span class="c1"># Perform crossover
</span>            <span class="n">offspring</span> <span class="o">=</span> <span class="n">parent1</span><span class="p">.</span><span class="nf">crossover</span><span class="p">(</span><span class="n">parent2</span><span class="p">)</span>

            <span class="c1"># Optional mutation
</span>            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">offspring</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">random</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.8</span><span class="p">:</span>  <span class="c1"># 30% mutation rate
</span>                    <span class="n">child</span><span class="p">.</span><span class="nf">mutate</span><span class="p">()</span>

            <span class="n">new_population</span><span class="p">.</span><span class="nf">extend</span><span class="p">(</span><span class="n">offspring</span><span class="p">)</span>

        <span class="c1"># Truncate population to original size
</span>        <span class="n">population</span> <span class="o">=</span> <span class="n">new_population</span><span class="p">[:</span><span class="n">POPULATION_SIZE</span><span class="p">]</span>

    <span class="c1"># Return the best chromosome
</span>    <span class="n">best_chromosome</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">check_average_propagation_cost</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">best_chromosome</span>
</code></pre></div></div> <p>I tried with starting out with a fully-connected graph and removing edges, but it did not work out as good as this implementation (not sure why).</p> <p>The next (and final) part of the broadcast challenge is to make it more efficient. For this, we just need to batch out our messages; instead of sending one message at a time, we send <code class="language-plaintext highlighter-rouge">n</code> messages at a time. The message sending can work on a ticker, where we send deltas of messages every 100ms.</p> <h2 id="conclusion">Conclusion</h2> <p>This challenge was a lot of fun; esp. the genetic algorithm part. I had a lot of fun implementing it. The final part of the challenge was to batch out messages, which I did not include along with code for the last part in this tutorial for brevity. I will leave that as an exercise for the reader. The next challenges are counter-based challenges, and I plan to do them in go, like the way the engineers at fly.io intended. The code for this part can be found <a href="https://github.com/sandeshbhusal/gossip-glomers">here</a>.</p>]]></content><author><name></name></author><category term="distributed systems"/><category term="rust"/><category term="algorithms"/><summary type="html"><![CDATA[My solutions to the Gossip Glomers challenge by fly.io]]></summary></entry><entry><title type="html">Writing (rewriting) a lexer</title><link href="https://sandeshbhusal.github.io/blog/2024/lexers/" rel="alternate" type="text/html" title="Writing (rewriting) a lexer"/><published>2024-11-20T00:00:00+00:00</published><updated>2024-11-20T00:00:00+00:00</updated><id>https://sandeshbhusal.github.io/blog/2024/lexers</id><content type="html" xml:base="https://sandeshbhusal.github.io/blog/2024/lexers/"><![CDATA[<p>I’ve been working on a very small expression evaluation engine for my project <a href="https://github.com/sandeshbhusal/Hulaak">Hulaak</a> for quite a bit now. Aptly, the expression evaluation language is called Hulang, and it’s a very simple language that works on JSON documents to modify them, kind of like what <a href="https://jqlang.github.io/jq/">jq</a> does. The language implementation is still in its infancy, but I’ve been working on it on and off for a few days now, and this is my kinda-sorta journey of writing a lexer for the language.</p> <h2 id="before-you-proceed">Before you proceed</h2> <p>This post is quite code-heavy as I expect the posts in this series to be. All implementation is done in Rust, but should be portable to other languages with minimal changes. I will be using Rust’s <code class="language-plaintext highlighter-rouge">regex</code> crate for the first implementation, and then move on to a more conventional implementation. The code snippets are not complete, and are meant to be illustrative of the concepts I am discussing. The complete code can be found in the <a href="https://gist.github.com/sandeshbhusal/5de659c5081b42eaf668e1e5bf090feb">gist</a> at the end of the post.</p> <h2 id="the-theory">The theory</h2> <p>From my PL course, I remember that the purpose of a lexer is to:</p> <blockquote> <p>Take the input string and convert it into a stream of tokens.</p> </blockquote> <p>This does not really matter a whole lot when you’re working with a small stream of input; for a language like Hulang, it’s pretty trivial to implement this with Regexes. But considering the overengineer that I am, I wanted to implement a lexer that I could reuse for projects that I <em>might</em> work on in the future 😉.</p> <p>A lexer is a giant combined NFA, from my PL course. The NFA matches over the given input string, landing in “accept” states as it goes on, and the tokens are generated from the accept states. Once there is a single accept state, the lexer knows that it has found a token, and it can generate the token from the accept state. If there are multiple accept states, it is ambigious, since we do not know what kind of token we should emit. In that case, we can do the following:</p> <ul> <li>Choose the longest match, and emit the token from that state.</li> <li>If there are multiple longest matches, have precedence rules in-place so that we can select a single one..</li> </ul> <pre><code class="language-mermaid">stateDiagram-v2
    [*] --&gt; S0
    S0: Start State
    
    %% Path for identifiers starting with 'i'
    S0 --&gt; S1: i
    S1: After 'i'
    S1 --&gt; S2: f
    S1 --&gt; ID: a-z
    S1 --&gt; [*]: end input
    
    %% Path for all other identifiers
    S0 --&gt; ID: a-z
    
    %% State for 'if' keyword
    S2: Keyword 'if'
    S2 --&gt; ID: a-z
    S2 --&gt; [*]: end input
    
    %% Identifier state
    ID: Identifier
    ID --&gt; ID: a-z
    ID --&gt; [*]: end input
</code></pre> <p>Considering the NFA above, if the input is “ap”, then we land in the “Identifier” state, and we can emit an identifier. If we have a “if”, however, we land in <em>both</em> the “Identifier” and the “Keyword ‘if’” states. In this case, we can choose the longest match, which is “‘if’”, and then order by precedence rule to get keyword “if” and not identifier “if”. If there is an input of “ifa”, we get “if” as the longest match at length 2, but if we continue to match, we eventually only have “ifa” as an identifier, and do not emit “keyword if” followed by “identifier a”.</p> <h2 id="brute-implementation-in-rust">Brute implementation in Rust.</h2> <p>I know and love Rust, so I will be making a very simple implementation in Rust itself. The format can be extended to support multiple tokens, and symbols, but for now we’ll just work with three things - a “.” token, “if” keyword and “identifier”.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">TokenType</span> <span class="p">{</span>
    <span class="n">Identifier</span><span class="p">,</span>
    <span class="n">Dot</span><span class="p">,</span>
    <span class="n">If</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div> <p>Each of these token types will have an accompanying <code class="language-plaintext highlighter-rouge">Regex</code> pattern. We will make this pattern static.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">PATTERN_MAP</span><span class="p">:</span> <span class="n">LazyLock</span><span class="o">&lt;</span><span class="n">IndexMap</span><span class="o">&lt;&amp;</span><span class="k">'static</span> <span class="nb">str</span><span class="p">,</span> <span class="n">TokenType</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="nn">LazyLock</span><span class="p">::</span><span class="nf">new</span><span class="p">(||</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">map</span> <span class="o">=</span> <span class="nn">IndexMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">for</span> <span class="n">variant</span> <span class="k">in</span> <span class="nn">TokenType</span><span class="p">::</span><span class="nf">iter</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">pattern</span> <span class="o">=</span> <span class="k">match</span> <span class="n">variant</span> <span class="p">{</span>
            <span class="nn">TokenType</span><span class="p">::</span><span class="n">Dot</span> <span class="k">=&gt;</span> <span class="s">r"\."</span><span class="p">,</span>
            <span class="nn">TokenType</span><span class="p">::</span><span class="n">If</span> <span class="k">=&gt;</span> <span class="s">r"if"</span><span class="p">,</span>
            <span class="nn">TokenType</span><span class="p">::</span><span class="n">Identifier</span> <span class="k">=&gt;</span> <span class="s">r"[a-zA-Z]+"</span><span class="p">,</span>
        <span class="p">};</span>

        <span class="n">map</span><span class="nf">.insert</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">variant</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">map</span>
<span class="p">});</span>
</code></pre></div></div> <p>The tokens will be placed in a <code class="language-plaintext highlighter-rouge">Token</code> struct that marks the start, end, and content of the tokens (I know Rust has tagged unions that can hold data, but I like this way better).</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Token</span> <span class="p">{</span>
    <span class="n">start</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">end</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">token_type</span><span class="p">:</span> <span class="n">TokenType</span><span class="p">,</span>
    <span class="n">content</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div> <p>The Token type does heap allocation for the content, but I will omit using lifetimes for readability. The lexer will be a struct that holds the input string and the current position in the input string.</p> <h2 id="the-regex-lexer">The regex lexer</h2> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">lexer</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Token</span><span class="o">&gt;</span><span class="p">,</span> <span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Token</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">String</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre></div></div> <p>With this, we have the outline of a lexer that can match tokens and return them. The function takes in a string and returns a result that returns either:</p> <ul> <li>A successful result with a vector of tokens.</li> <li>An error with a vector of tokens that were successfully matched, and the remaining input string that was not matched.</li> </ul> <p>Now from the <a href="#the-theory">Theory</a>, we know that we need a giant DFA that will encompass all rules, and help us with the matching process. We can implement this giant DFA as a <a href="https://docs.rs/regex/latest/regex/struct.RegexSet.html">RegexSet</a> type that gives us the ability to match multiple regexes at once. We can then iterate over the matches and choose the longest match.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">lexer</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Token</span><span class="o">&gt;</span><span class="p">,</span> <span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Token</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">String</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">token</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">regex_dfa</span> <span class="o">=</span> <span class="nn">RegexSet</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">PATTERN_MAP</span><span class="nf">.keys</span><span class="p">())</span><span class="nf">.unwrap</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div> <p>Now the matching can begin. The algorithm goes like this:</p> <ol> <li>While the input string has a whitespace, skip the whitespace, and find an actual character we can start matching from.</li> <li>While the offset is less than the input string length, we can match tokens.</li> <li>Match the regex set with the input string, and get the longest match at the offset.</li> <li>If there is no match, return an error with the tokens matched so far, and the remaining input string.</li> </ol> <p>The code looks like this:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">lexer</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Token</span><span class="o">&gt;</span><span class="p">,</span> <span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Token</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">String</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">tokens</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">regex_dfa</span> <span class="o">=</span> <span class="nn">RegexSet</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">PATTERN_MAP</span><span class="nf">.keys</span><span class="p">())</span><span class="nf">.unwrap</span><span class="p">();</span>

    <span class="k">while</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="n">input</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">off</span><span class="p">,</span> <span class="n">_</span><span class="p">))</span> <span class="o">=</span> <span class="n">input</span>
            <span class="nf">.chars</span><span class="p">()</span>
            <span class="nf">.enumerate</span><span class="p">()</span>
            <span class="nf">.find</span><span class="p">(|(</span><span class="n">off</span><span class="p">,</span> <span class="n">ip</span><span class="p">)|</span> <span class="o">*</span><span class="n">off</span> <span class="o">&gt;=</span> <span class="n">offset</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ip</span><span class="nf">.is_whitespace</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">off</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">tokens</span><span class="p">);</span> <span class="c1">// Nothing except whitespaces found. Return lexed this far.</span>
        <span class="p">}</span>

        <span class="c1">// Get all matches for the current offset.</span>
        <span class="k">let</span> <span class="n">matched_patterns_index</span> <span class="o">=</span> <span class="n">regex_dfa</span><span class="nf">.matches</span><span class="p">(</span><span class="o">&amp;</span><span class="n">input</span><span class="p">[</span><span class="n">offset</span><span class="o">..</span><span class="p">]);</span>
        <span class="k">if</span> <span class="n">matched_patterns_index</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Err</span><span class="p">((</span><span class="n">tokens</span><span class="p">,</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">input</span><span class="p">[</span><span class="n">offset</span><span class="o">..</span><span class="p">])</span><span class="nf">.to_string</span><span class="p">()));</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">matched_strings_and_types</span> <span class="o">=</span> <span class="n">matched_patterns_index</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">pattern_index</span><span class="p">|</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">pattern_str</span> <span class="o">=</span> <span class="n">PATTERN_MAP</span><span class="nf">.keys</span><span class="p">()</span><span class="nf">.nth</span><span class="p">(</span><span class="n">pattern_index</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">token_type</span> <span class="o">=</span> <span class="n">PATTERN_MAP</span><span class="nf">.get</span><span class="p">(</span><span class="n">pattern_str</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">matched_string</span> <span class="o">=</span> <span class="nn">Regex</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">pattern_str</span><span class="p">)</span>
                <span class="nf">.expect</span><span class="p">(</span><span class="s">"Invalid regex pattern -- This should never happen"</span><span class="p">)</span>
                <span class="nf">.find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">input</span><span class="p">[</span><span class="n">offset</span><span class="o">..</span><span class="p">])</span>
                <span class="nf">.unwrap</span><span class="p">()</span>
                <span class="nf">.as_str</span><span class="p">();</span>
            <span class="p">(</span><span class="n">token_type</span><span class="p">,</span> <span class="n">matched_string</span><span class="p">)</span>
        <span class="p">});</span>

        <span class="k">let</span> <span class="n">longest_match</span> <span class="o">=</span> <span class="n">matched_strings_and_types</span>
            <span class="nf">.max_by_key</span><span class="p">(|(</span><span class="n">_tokentype</span><span class="p">,</span> <span class="n">matched</span><span class="p">)|</span> <span class="n">matched</span><span class="nf">.len</span><span class="p">())</span>
            <span class="nf">.expect</span><span class="p">(</span><span class="s">"Something should've matched"</span><span class="p">);</span>

        <span class="k">let</span> <span class="p">(</span><span class="n">token_type</span><span class="p">,</span> <span class="n">matched_string</span><span class="p">)</span> <span class="o">=</span> <span class="n">longest_match</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">start</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">end</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">matched_string</span><span class="nf">.len</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">r</span><span class="err">#</span><span class="k">type</span> <span class="o">=</span> <span class="o">*</span><span class="n">token_type</span><span class="p">;</span>

        <span class="n">tokens</span><span class="nf">.push</span><span class="p">(</span><span class="n">Token</span> <span class="p">{</span>
            <span class="n">r</span><span class="err">#</span><span class="k">type</span><span class="p">,</span>
            <span class="n">start</span><span class="p">,</span>
            <span class="n">end</span><span class="p">,</span>
            <span class="n">content</span><span class="p">:</span> <span class="n">matched_string</span><span class="nf">.to_string</span><span class="p">(),</span>
        <span class="p">});</span>

        <span class="n">offset</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nf">Ok</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p>The regexset returns a iterable of indexes of the matched patterns, and we can then get the matched string from the input string. We then find the longest match, and create a token from that match. The offset is then moved to the end of the matched string, and the process continues until the end of the input string.</p> <h3 id="issues-with-this-implementation">Issues with this implementation</h3> <p>The implementation is quite elegant at the first glance - to add more tokens, we just add them to the <code class="language-plaintext highlighter-rouge">TokenType</code> map, and the <code class="language-plaintext highlighter-rouge">PATTERN_MAP</code>. The lexer token types are ordered by default in the TokenType map (the latter tokens in the enum have more precedence than the upper tokens), so we don’t need to worry about breaking ties. The issues with this implementation are:</p> <ul> <li>Usage of RegexSet and Regex is not very performant.</li> <li>In most cases, the conflicts arise with matching “identifier” and “token” types from my experience. It is not worth it to use Regex for this case.</li> <li>We may not want to “eat” whitespace all the time - we have cases like matching string literals where we would like to keep the whitespace (albeit this can be solved by adding a new regex type for string literal).</li> </ul> <p>I glossed over the lexer implementation of lexers that <a href="https://brunocalza.me/writing-a-simple-lexer-in-rust/">other people have done</a> and this implementation looks unnecessarily brute-forcy.</p> <h2 id="writing-a-better-lexer">Writing a better lexer.</h2> <p>I want the implementation of the lexer to be more performant, and more conventional - in tune with what people in the industry actually do instead of creating a large messy RegexSet to hide from the actual implementation. If you think about it, it’s really simple - the conflicts generally arise when matching inputs like “if” and “identifier”, or “&gt;=” and “&gt;” and “=”.</p> <p>The lexer in this case will become a simple state matchine we can code by-hand. We start by reusing the token_type enum and token struct from before, and defining a lexer struct. The struct looks like this:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">Lexer</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="nb">char</span><span class="p">],</span>
    <span class="n">position</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div> <p>Since rust has excellent default support for Unicode characters, we can use <code class="language-plaintext highlighter-rouge">char</code> type. Next, we begin by defining some basic operations on the lexer struct.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">LexerResult</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">LexerError</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">Lexer</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="nb">char</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="n">Lexer</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="n">Lexer</span> <span class="p">{</span> <span class="n">input</span><span class="p">,</span> <span class="n">position</span><span class="p">:</span> <span class="mi">0</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">peek</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">char</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="k">if</span> <span class="k">self</span><span class="py">.position</span> <span class="o">&gt;=</span> <span class="k">self</span><span class="py">.input</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">(</span><span class="k">self</span><span class="py">.input</span><span class="p">[</span><span class="k">self</span><span class="py">.position</span><span class="p">])</span>
        <span class="p">};</span>

        <span class="n">res</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">advance</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">LexerResult</span><span class="o">&lt;</span><span class="nb">char</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.position</span> <span class="o">&gt;=</span> <span class="k">self</span><span class="py">.input</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">LexerError</span><span class="p">::</span><span class="n">EndOfInput</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="nf">Ok</span><span class="p">(</span><span class="k">self</span><span class="py">.input</span><span class="p">[</span><span class="k">self</span><span class="py">.position</span><span class="p">]);</span>
        <span class="k">self</span><span class="py">.position</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">res</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">eat_whitespace</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">LexerResult</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.peek</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="o">!</span><span class="n">ch</span><span class="nf">.is_whitespace</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.advance</span><span class="p">()</span><span class="o">?</span><span class="p">;</span> <span class="c1">// Discard the whitespace.</span>
        <span class="p">}</span>
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>All the functions are pretty self-explanatory. We begin by creating a lexer that tracks the position in the input string. We can peek at the current character, advance the position, and eat whitespace.</p> <p>Now we need a function that actuallly does the lexing.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">lex</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">LexerResult</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Token</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">tokens</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Token</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="c1">// Start, eat whitespace.</span>
    <span class="k">self</span><span class="nf">.eat_whitespace</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Match the first character.</span>
    <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">current_char</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.peek</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">current_char</span> <span class="p">{</span>
            <span class="sc">'a'</span><span class="o">..</span><span class="sc">'z'</span> <span class="p">|</span> <span class="sc">'A'</span><span class="o">..</span><span class="sc">'Z'</span> <span class="p">|</span> <span class="sc">'_'</span> <span class="k">=&gt;</span> <span class="n">tokens</span><span class="nf">.push</span><span class="p">(</span><span class="k">self</span><span class="nf">.match_identifier_or_keyword</span><span class="p">()</span><span class="o">?</span><span class="p">),</span>
            <span class="n">symb</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">tok_type</span> <span class="o">=</span> <span class="k">match</span> <span class="n">symb</span> <span class="p">{</span>
                    <span class="sc">'.'</span> <span class="k">=&gt;</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">Dot</span><span class="p">,</span>
                    <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">LexerError</span><span class="p">::</span><span class="nf">PartiallyMatchedInput</span><span class="p">(</span>
                            <span class="n">tokens</span><span class="p">,</span>
                            <span class="k">self</span><span class="py">.input</span><span class="p">[</span><span class="k">self</span><span class="py">.position</span><span class="o">..</span><span class="p">]</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.collect</span><span class="p">(),</span>
                        <span class="p">))</span>
                    <span class="p">}</span>
                <span class="p">};</span>

                <span class="n">tokens</span><span class="nf">.push</span><span class="p">(</span><span class="n">Token</span> <span class="p">{</span>
                    <span class="n">start</span><span class="p">:</span> <span class="k">self</span><span class="py">.position</span><span class="p">,</span>
                    <span class="n">end</span><span class="p">:</span> <span class="k">self</span><span class="py">.position</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="n">token_type</span><span class="p">:</span> <span class="n">tok_type</span><span class="p">,</span>
                    <span class="n">content</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="k">self</span><span class="nf">.advance</span><span class="p">()</span><span class="o">?</span><span class="p">),</span>
                <span class="p">});</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">self</span><span class="nf">.eat_whitespace</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// End, eat all whitespace</span>
    <span class="k">self</span><span class="nf">.eat_whitespace</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="k">return</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">tokens</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>The lex function starts off by creating the return array of tokens. Then we discard all whitespace until we hit a char we can parse. Based on the char at the start of the input stream, we can match either an identifier/keyword, or a symbol (our symbol is limited to just ‘.’ for now). The match_identifier_or_keyword function is a helper function that matches the identifier or keyword.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    <span class="k">fn</span> <span class="nf">match_identifier_or_keyword</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">LexerResult</span><span class="o">&lt;</span><span class="n">Token</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">start</span> <span class="o">=</span> <span class="k">self</span><span class="py">.position</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">startsym</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.advance</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">buffer</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">startsym</span><span class="p">);</span>
        
        <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.peek</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ch</span><span class="nf">.is_ascii_alphanumeric</span><span class="p">()</span> <span class="p">||</span> <span class="n">ch</span> <span class="o">==</span> <span class="sc">'_'</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ch</span><span class="nf">.is_whitespace</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">buffer</span><span class="nf">.push</span><span class="p">(</span><span class="k">self</span><span class="nf">.advance</span><span class="p">()</span><span class="o">?</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">kwmatch</span> <span class="o">=</span> <span class="k">match</span> <span class="n">buffer</span><span class="nf">.as_ref</span><span class="p">()</span> <span class="p">{</span>
            <span class="s">"if"</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">KwIf</span><span class="p">),</span>
            <span class="n">_</span> <span class="k">=&gt;</span> <span class="nb">None</span><span class="p">,</span>
        <span class="p">};</span>

        <span class="k">return</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">Token</span> <span class="p">{</span>
            <span class="n">start</span><span class="p">,</span>
            <span class="n">end</span><span class="p">:</span> <span class="n">start</span> <span class="o">+</span> <span class="n">buffer</span><span class="nf">.len</span><span class="p">(),</span>
            <span class="n">token_type</span><span class="p">:</span> <span class="n">kwmatch</span><span class="nf">.unwrap_or</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">Identifier</span><span class="p">),</span>
            <span class="n">content</span><span class="p">:</span> <span class="n">buffer</span><span class="p">,</span>
        <span class="p">});</span>
    <span class="p">}</span>
</code></pre></div></div> <p>The function begins by reading off the start char into a string itself. Then until we have ascii alphanumeric char or “_” in the input stream, we will continue to push it into the buffer. When we hit a non-alphanumeric char, we break out of the loop and check if the buffer is a keyword. If it is, we return the keyword token, else we return the identifier token.</p> <p>The lexer is now complete. The complete lexer code looks like <a href="https://gist.github.com/sandeshbhusal/5de659c5081b42eaf668e1e5bf090feb">this</a>.</p> <h2 id="concluding-remarks">Concluding remarks</h2> <p>I had a lot of fun writing (and rewriting) this lexer. While the task of writing something by hand might sound daunting at first, and we might immediately want to run off to write code with libraries like <code class="language-plaintext highlighter-rouge">Regex</code>, it can be beneficial to write code by hand sometimes to solidify understanding and challenge oneself. The lexer implementation above is very simple - we can improve further on it, e.g. by adding support for string literals, comments, and other symbols. The lexer can be extended to support more complex languages, and can be used as a base for writing a parser for the language. There is also the opportunity for performance optimization - we could remove all memory allocations and use slices instead of strings, and we could also use a more efficient data structure to store the tokens. However, those are topics for another day.</p> <p>I hope you enjoyed reading this post. If you have any feedback, feel free to reach out to me on <a href="https://linkedin.com/in/sandeshbhusal">LinkedIn</a>. I’m always open to feedback and suggestions. Until next time, happy coding! 🚀</p>]]></content><author><name></name></author><category term="algorithms"/><category term="programming languages"/><summary type="html"><![CDATA[A journey of writing a lexer for a simple language in Rust.]]></summary></entry><entry><title type="html">Binary search is Bananas!</title><link href="https://sandeshbhusal.github.io/blog/2023/binary-search/" rel="alternate" type="text/html" title="Binary search is Bananas!"/><published>2023-08-19T00:00:00+00:00</published><updated>2023-08-19T00:00:00+00:00</updated><id>https://sandeshbhusal.github.io/blog/2023/binary-search</id><content type="html" xml:base="https://sandeshbhusal.github.io/blog/2023/binary-search/"><![CDATA[<h2 id="refresher">Refresher</h2> <p>Binary search is one of the most trivial and elegant algorithms to understand, and yet, equally easy to get wrong while implementing it. There are a couple of checkpoints, comparisons and constants, which contribute to the running of the algorithm, which can be easily mistaken. In essence, binary search works by partitioning a given array into two halves successively, until a single element (or position) is reached where the target of interest may be. This means, during each run of the algorithm, we have the following choices to make:</p> <ul> <li>Has the algorithm terminated? If so, has it found the target (or position)?</li> <li>Which array is the array of interest currently, and which subsection will we explore next?</li> <li>Will the algorithm / loop terminate?</li> </ul> <p>Binary search keeps track of position information in two pointers (although a variant of <a href="https://www.geeksforgeeks.org/meta-binary-search-one-sided-binary-search/">one-sided binary search</a> is also possible). These pointers, can be called <code class="language-plaintext highlighter-rouge">low</code> and <code class="language-plaintext highlighter-rouge">high</code>, and represent the range of the array we are searching within (inclusive), i.e. <code class="language-plaintext highlighter-rouge">[low, high]</code>.</p> <h2 id="pseudocode">Pseudocode</h2> <p>Let’s proceed with a simple pseudocode implementation which leaves a lot of blanks out to be filled in later on (proofs, etc). It looks something like this:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">binarysearch</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">low</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="n">__</span><span class="p">,</span> <span class="n">__</span>
    <span class="k">while</span> <span class="n">low</span> <span class="n">__</span> <span class="n">high</span><span class="p">:</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">low</span> <span class="o">+</span> <span class="n">high</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">array</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mid</span>
        <span class="k">if</span> <span class="n">array</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="n">__</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">low</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="n">__</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">high</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="n">__</span>

    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div></div> <p>You must’ve noticed a few blanks in the pseudocode above. Don’t worry - we’ll fill them later on. For now, let’s define some properties we’d like the algorithm to have.</p> <h3 id="desired-properties">Desired properties.</h3> <p>Like the questions above, the desired properties for the algorithm can be described as follows:</p> <h4 id="correctness">Correctness:</h4> <ul> <li>The Algorithm must always produce a correct answer. That is, if an element exists in the array, it should return the index of the said element. Otherwise, it should return -1. If an element exists and the algorithm returns -1, it is incorrect, and the same can be said when a non-existing element search returns an index within the array.</li> </ul> <blockquote> <p>This kind of issue generally manifests itself in corner cases, like in a unit-sized array, or when the target element lies on the array boundaries (leftmost/rightmost element).</p> </blockquote> <h4 id="liveness">Liveness:</h4> <ul> <li>The Algorithm must always terminate. This means, for every array, the algorithm must produce an output and exit.</li> </ul> <blockquote> <p>This kind of issue generally manifests itself when the comparision operations within the algorithm fail. For an example, the bounds do not get updated, or there is a stray equality comparision which lets the algorithm run without stopping.</p> </blockquote> <h2 id="filling-in-the-blanks">Filling in the blanks</h2> <p>Let’s start filling in the blanks on the above code.</p> <h3 id="determining-search-starting-bounds-and-loop-invariant">Determining search starting bounds and loop invariant</h3> <p>The first blank decides where the array search starts. It is evident that we want to start searching from the beginning of the array, so it has the value of \(0\). The same can not be said for the high bound, though, because it determines what the loop condition will be. So let’s fill that out first.</p> <p>We know that a binary search converges when the length of the search array becomes unit, i.e. \(1\). This means, the left bound and right bound should coincide (since we are searching in an inclusive array, i.e. \( [low, high] \)). So the algorithm’s loop should run until the bounds coincide, at which point either the element is already found and returned, or the element was not found and the algorithm terminates. So, we have two ways to show non-coinciding bounds: \(loop\ while\ \ (low &lt; high)\) or \(loop\ while\ \ (low \neq high)\)</p> <p>If we opt to go with the second method, i.e. <code class="language-plaintext highlighter-rouge">loop while (left != right)</code>, then, the right bound cannot be set to <code class="language-plaintext highlighter-rouge">len(array) - 1</code>, since in a two-sized array, this will effectively prevent the looping from happening at all. So, the bounds and loop invariants can be determined as:</p> <ol> <li>If <code class="language-plaintext highlighter-rouge">low = 0</code>, <code class="language-plaintext highlighter-rouge">high = len(array)</code>, then the loop invariant to hold is <code class="language-plaintext highlighter-rouge">low &lt; high</code>.</li> <li>If <code class="language-plaintext highlighter-rouge">low = 0</code>, <code class="language-plaintext highlighter-rouge">high = len(array) - 1</code>, then the loop invariant to hold is <code class="language-plaintext highlighter-rouge">low &lt;= high</code>.</li> </ol> <h3 id="determining-the-conditional-check-at-mid">Determining the conditional check at <code class="language-plaintext highlighter-rouge">mid</code>.</h3> <p>Looking at the pseudocode again, we have this segment to fill out:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="bp">...</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">low</span> <span class="o">+</span> <span class="n">high</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">array</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mid</span>
        <span class="k">if</span> <span class="n">array</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="n">__</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">low</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="n">__</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">high</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="n">__</span>
<span class="bp">...</span>
</code></pre></div></div> <p>Which is the inner part of the loop. The first check is to see if <code class="language-plaintext highlighter-rouge">array[mid]</code> meets the target, is smaller, etc. Since we have assumed an array sorted in the ascending order, we update the lower bound <em>only</em> when the middle element is such that the target cannot be in the LHS of the array. This means, target could be either less than, or equal to <code class="language-plaintext highlighter-rouge">array[mid]</code>. However, as we see above, when <code class="language-plaintext highlighter-rouge">array[mid] == target</code>, we have an early return. So the only conditional that can fit is <code class="language-plaintext highlighter-rouge">if array[mid] &lt; target</code>.</p> <h3 id="updating-bounds">Updating bounds</h3> <p>Lastly remaining - to update the bounds. When the middle element of the array is smaller than the target, there is no point starting the low bound again from midpoint, so we update it as <code class="language-plaintext highlighter-rouge">low = mid + 1</code>. However, if it is not smaller than the target, it means, it could be greater than the target, or equal to it. Since we already do an equality comparision with target above it, it would be strictly greater than the target. As such, we can exclude it from search next, so we update <code class="language-plaintext highlighter-rouge">high = mid - 1</code> in the next blank.</p> <h2 id="final-solution">Final solution</h2> <p>This generates the following code finally:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">binarysearch</span> <span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">low</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">low</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="p">:</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">low</span> <span class="o">+</span> <span class="n">high</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">array</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mid</span>
        <span class="k">if</span> <span class="n">array</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">low</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">high</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div></div> <h2 id="proof-of-termination">Proof of termination</h2> <p>We are interested in checking that the algorithm terminates properly. Since we have chosen multiple constants and equality checks above based on one-another, they form a subset of choices that could’ve been made, so we will not check for correctness now.</p> <p>For proof of termination, we will check two scenarios, based on the bounds we chose to go with. They are:</p> <ol> <li><code class="language-plaintext highlighter-rouge">high = len(array) - 1</code> and loop invariant as <code class="language-plaintext highlighter-rouge">low &lt;= high</code></li> <li><code class="language-plaintext highlighter-rouge">high = len(array)</code> and loop invariant as <code class="language-plaintext highlighter-rouge">low &lt; high</code></li> </ol> <p>Now, we look to proving the loop will indeed converge, and for this, we will use proof by contradiction.</p> <h3 id="scenario-1">Scenario #1</h3> <ul> <li>For the loop to continue running forever when <code class="language-plaintext highlighter-rouge">loop until low &lt;= high</code> invariant is upheld, the <code class="language-plaintext highlighter-rouge">low</code> bound should be strictly less than or equal to the <code class="language-plaintext highlighter-rouge">high</code> bound. This means, no matter what happens, <code class="language-plaintext highlighter-rouge">low</code> can never exceed <code class="language-plaintext highlighter-rouge">high</code>.</li> <li>Which means <code class="language-plaintext highlighter-rouge">low = mid + 1</code>, i.e. <code class="language-plaintext highlighter-rouge">low = (low + high) // 2 + 1</code> never exceeds high.</li> <li>When <code class="language-plaintext highlighter-rouge">low == high</code>, however, <code class="language-plaintext highlighter-rouge">low = (low + high) // 2 + 1</code> becomes <code class="language-plaintext highlighter-rouge">low = (high + high) // 2 + 1</code>, i.e. <code class="language-plaintext highlighter-rouge">low = high + 1</code>.</li> <li>This means, in the next iteration, <code class="language-plaintext highlighter-rouge">low = high + 1</code> will violate the loop invariant, and the loop converges.</li> </ul> <h3 id="scenario-2">Scenario #2</h3> <ul> <li>For the loop to continue running forever when <code class="language-plaintext highlighter-rouge">loop until low &lt; high</code> invariant is upheld, the <code class="language-plaintext highlighter-rouge">low</code> bound should never be equal to or greater than the <code class="language-plaintext highlighter-rouge">high</code> bound. The greater condition is already proved above.</li> <li>This means <code class="language-plaintext highlighter-rouge">low</code> can never be equal to <code class="language-plaintext highlighter-rouge">high</code>.</li> <li>In a finally-converging loop with range size = 2, i.e. <code class="language-plaintext highlighter-rouge">low = high - 1</code>, by virtue of integer division flooring the <code class="language-plaintext highlighter-rouge">mid</code> value becomes: <code class="language-plaintext highlighter-rouge">mid = (low + high) // 2</code>, i.e. <code class="language-plaintext highlighter-rouge">mid = (high + high - 1) // 2</code>. Upon adding <code class="language-plaintext highlighter-rouge">1</code> to this in the loop update, <code class="language-plaintext highlighter-rouge">low = mid + 1</code>, it becomes <code class="language-plaintext highlighter-rouge">low = (high + high - 1) // 2 + 1</code>, which becomes equal to <code class="language-plaintext highlighter-rouge">high</code>.</li> <li>This means, in the next iteration, <code class="language-plaintext highlighter-rouge">low == high</code> will violate the loop invariant and the loop converges.</li> </ul> <h2 id="conclusion">Conclusion</h2> <p>This was a longer-than-expected blog post. Please let me know of any errors in the post by raising a issue in the <a href="https://github.com/sandeshbhusal/sandeshbhusal.github.io">github repository for this blog</a>.</p>]]></content><author><name></name></author><category term="algorithms"/><category term="proofs"/><summary type="html"><![CDATA[Refresher Binary search is one of the most trivial and elegant algorithms to understand, and yet, equally easy to get wrong while implementing it. There are a couple of checkpoints, comparisons and constants, which contribute to the running of the algorithm, which can be easily mistaken. In essence, binary search works by partitioning a given array into two halves successively, until a single element (or position) is reached where the target of interest may be. This means, during each run of the algorithm, we have the following choices to make:]]></summary></entry><entry><title type="html">a post with formatting and links</title><link href="https://sandeshbhusal.github.io/blog/2015/formatting-and-links/" rel="alternate" type="text/html" title="a post with formatting and links"/><published>2015-03-15T16:40:16+00:00</published><updated>2015-03-15T16:40:16+00:00</updated><id>https://sandeshbhusal.github.io/blog/2015/formatting-and-links</id><content type="html" xml:base="https://sandeshbhusal.github.io/blog/2015/formatting-and-links/"><![CDATA[<p>Jean shorts raw denim Vice normcore, art party High Life PBR skateboard stumptown vinyl kitsch. Four loko meh 8-bit, tousled banh mi tilde forage Schlitz dreamcatcher twee 3 wolf moon. Chambray asymmetrical paleo salvia, sartorial umami four loko master cleanse drinking vinegar brunch. <a href="https://www.pinterest.com">Pinterest</a> DIY authentic Schlitz, hoodie Intelligentsia butcher trust fund brunch shabby chic Kickstarter forage flexitarian. Direct trade <a href="https://en.wikipedia.org/wiki/Cold-pressed_juice">cold-pressed</a> meggings stumptown plaid, pop-up taxidermy. Hoodie XOXO fingerstache scenester Echo Park. Plaid ugh Wes Anderson, freegan pug selvage fanny pack leggings pickled food truck DIY irony Banksy.</p> <h4 id="hipster-list">Hipster list</h4> <ul> <li>brunch</li> <li>fixie</li> <li>raybans</li> <li>messenger bag</li> </ul> <h4 id="check-list">Check List</h4> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>Brush Teeth</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Put on socks <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>Put on left sock</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Put on right sock</li> </ul> </li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>Go to school</li> </ul> <p>Hoodie Thundercats retro, tote bag 8-bit Godard craft beer gastropub. Truffaut Tumblr taxidermy, raw denim Kickstarter sartorial dreamcatcher. Quinoa chambray slow-carb salvia readymade, bicycle rights 90’s yr typewriter selfies letterpress cardigan vegan.</p> <hr/> <p>Pug heirloom High Life vinyl swag, single-origin coffee four dollar toast taxidermy reprehenderit fap distillery master cleanse locavore. Est anim sapiente leggings Brooklyn ea. Thundercats locavore excepteur veniam eiusmod. Raw denim Truffaut Schlitz, migas sapiente Portland VHS twee Bushwick Marfa typewriter retro id keytar.</p> <blockquote> <p>We do not grow absolutely, chronologically. We grow sometimes in one dimension, and not in another, unevenly. We grow partially. We are relative. We are mature in one realm, childish in another. —Anais Nin</p> </blockquote> <p>Fap aliqua qui, scenester pug Echo Park polaroid irony shabby chic ex cardigan church-key Odd Future accusamus. Blog stumptown sartorial squid, gastropub duis aesthetic Truffaut vero. Pinterest tilde twee, odio mumblecore jean shorts lumbersexual.</p>]]></content><author><name></name></author><category term="sample-posts"/><category term="formatting"/><category term="links"/><summary type="html"><![CDATA[march & april, looking forward to summer]]></summary></entry></feed>