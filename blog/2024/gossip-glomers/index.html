<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Gossip Glomers - Efficient Broadcast | Bhusal's </title> <meta name="author" content="Sandesh Bhusal"> <meta name="description" content="My solutions to the Gossip Glomers challenge by fly.io"> <meta name="keywords" content="sandesh-bhusal,sandesh,bhusal,blog"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Spline+Sans+Mono:ital,wght@0,300..700;1,300..700|Material+Icons|PT+Serif:ital,wght@0,400;0,700;1,400;1,700|Inter:ital,wght@0,400;0,700;1,400;1,700&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-monokai.css?8ae2e3994bdbc9ef556d679b3cd92642" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://sandeshbhusal.github.io/blog/2024/gossip-glomers/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav sticky-bottom-footer"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Bhusal's </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/"> </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link"><i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Gossip Glomers - Efficient Broadcast</h1> <p class="post-meta"> Created in December 25, 2024 </p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/tag/distributed-systems"> <i class="fa-solid fa-hashtag fa-sm"></i> distributed systems</a>   <a href="/blog/tag/rust"> <i class="fa-solid fa-hashtag fa-sm"></i> rust</a>   <a href="/blog/tag/algorithms"> <i class="fa-solid fa-hashtag fa-sm"></i> algorithms</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p><a href="https://fly.io/dist-sys/" rel="external nofollow noopener" target="_blank">Gossip Glomers</a> is a distributed systems challenge created by <a href="https://fly.io" rel="external nofollow noopener" target="_blank">fly.io</a>, where participants are expected to work around a simulating library called <code class="language-plaintext highlighter-rouge">maelstrom</code> that simulates failures and latencies in a distributed system. The library provided works with <code class="language-plaintext highlighter-rouge">go</code>, but being the rustacean that I am, I decided to rewrite the library in Rust, and implement solutions to the challenges. The <a href="">specifications</a> are publicly available (and well-documented) so it was a breeze to go through. In this post, I will only explain the solutions to the challenge upto the <em>efficient broadcast</em> challenge.</p> <h2 id="about-this-post">About this post.</h2> <p>This post is quite code-heavy as I expect the posts in this series to be. The challenge encompasses a lot of concepts in distributed systems, and frankly, squeezing all solutions into a single post will not make any sense. Instead, they will be spread out over posts in this series.</p> <h2 id="setting-up-the-project">Setting up the project</h2> <p>The ‘maelstrom’ binary can be downloaded and it unsurprisingly works right out of the box. For starters, I created the following project structure:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">.</span>
├── Cargo.lock
├── Cargo.toml
├── maelstrom
    ├── maelstrom
    └── ..
└── src
    ├── main.rs
    └── message.rs
</code></pre></div></div> <p>The <code class="language-plaintext highlighter-rouge">main.rs</code> file is responsible to run the entire application, and <code class="language-plaintext highlighter-rouge">message.rs</code> describes the types of messages we support.</p> <p>The <code class="language-plaintext highlighter-rouge">message.rs</code> file has the following contents:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">serde</span><span class="p">::{</span><span class="n">Deserialize</span><span class="p">,</span> <span class="n">Serialize</span><span class="p">};</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Serialize,</span> <span class="nd">Deserialize,</span> <span class="nd">Clone)]</span>
<span class="nd">#[serde(rename_all</span> <span class="nd">=</span> <span class="s">"snake_case"</span><span class="nd">)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Message</span> <span class="p">{</span>
    <span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="n">src</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="n">dest</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="n">body</span><span class="p">:</span> <span class="n">MessageBody</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Serialize,</span> <span class="nd">Deserialize,</span> <span class="nd">Clone)]</span>
<span class="nd">#[serde(tag</span> <span class="nd">=</span> <span class="s">"type"</span><span class="nd">,</span> <span class="nd">rename_all</span> <span class="nd">=</span> <span class="s">"snake_case"</span><span class="nd">)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">MessageBody</span> <span class="p">{</span>
    <span class="n">Echo</span> <span class="p">{</span>
        <span class="n">msg_id</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
        <span class="n">echo</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="n">EchoOk</span> <span class="p">{</span>
        <span class="n">msg_id</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
        <span class="n">in_reply_to</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
        <span class="n">echo</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="n">Init</span> <span class="p">{</span>
        <span class="n">msg_id</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
        <span class="n">node_id</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
        <span class="n">node_ids</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="n">InitOk</span> <span class="p">{</span>
        <span class="n">in_reply_to</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
    <span class="p">},</span>
<span class="p">}</span>
</code></pre></div></div> <p>One thing that I missed in the beginning was to return an <code class="language-plaintext highlighter-rouge">InitOk</code> message (which was outlined in the spec). Since the go library does that automatically, and we are not using go, we need to implement everything from scratch. Using serde makes this whole thing a breeze. The common fields go into <code class="language-plaintext highlighter-rouge">Message</code> struct, and fields specific to each type of message go to <code class="language-plaintext highlighter-rouge">MessageBody</code>. The body is named <code class="language-plaintext highlighter-rouge">type</code> in the incoming json message, and it seamlessly works with the following message for deserialization:</p> <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nl">"src"</span><span class="p">:</span><span class="w"> </span><span class="s2">"n0"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"dest"</span><span class="p">:</span><span class="w"> </span><span class="s2">"n1"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"body"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"echo_ok"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"msg_id"</span><span class="p">:</span><span class="w"> </span><span class="mi">123</span><span class="p">,</span><span class="w">
        </span><span class="nl">"echo"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Echo echo"</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div> <p>The next thing would be to implement methods to read/write from/to stdin/stdout.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">buffer</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">node</span><span class="p">:</span> <span class="n">Node</span> <span class="o">=</span> <span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">();</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="n">buffer</span><span class="nf">.clear</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="nf">stdin</span><span class="p">()</span><span class="nf">.read_line</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">buffer</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="k">if</span> <span class="n">len</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">message</span><span class="p">:</span> <span class="n">Message</span> <span class="o">=</span> <span class="k">match</span> <span class="nn">serde_json</span><span class="p">::</span><span class="nf">from_str</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">msg</span><span class="p">,</span>
            <span class="nf">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"Error parsing message: {}"</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">};</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">=</span> <span class="n">node</span><span class="nf">.handle_message</span><span class="p">(</span><span class="n">message</span><span class="p">)</span> <span class="p">{</span>
            <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"Error handling message: {}"</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div> <p>The node does not need to be concurrent - we process messages serially. The code keeps reading from stdin, creating a message (after deserializing), and passing the deserialized messages to the node. Next, the implementation for <code class="language-plaintext highlighter-rouge">Node</code> type.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Debug,</span> <span class="nd">Default,</span> <span class="nd">Clone)]</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="n">id</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">node_ids</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">current_msg_id</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">id</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">node_ids</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="n">Node</span> <span class="p">{</span>
            <span class="n">id</span><span class="p">,</span>
            <span class="n">node_ids</span><span class="p">,</span>
            <span class="n">current_msg_id</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">get_next_message_id</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">handle_echo</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">echo_in</span><span class="p">:</span> <span class="n">Message</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">handle_message</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="n">Message</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>The <code class="language-plaintext highlighter-rouge">Node</code> struct itself is very simple - it stores the node’s <code class="language-plaintext highlighter-rouge">id</code>, the <code class="language-plaintext highlighter-rouge">node_ids</code> of all nodes in the distributed system, and stores the current message id to use (no need to use atomic ints since we are just processing stuff in a single-thread). Next would be the implementation of each of these handlers. The <code class="language-plaintext highlighter-rouge">get_next_message_id</code> itself is very simple:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">get_next_message_id</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">current_id</span> <span class="o">=</span> <span class="k">self</span><span class="py">.current_msg_id</span><span class="p">;</span>
    <span class="k">self</span><span class="py">.current_msg_id</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">current_id</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="a-very-basic-echo">A very basic echo</h2> <p>In order to handle messages in the Node, we dispatch it to the <code class="language-plaintext highlighter-rouge">handle_message</code> function from our <code class="language-plaintext highlighter-rouge">main</code> function:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">handle_message</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="n">Message</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">match</span> <span class="n">message</span><span class="py">.body</span><span class="nf">.clone</span><span class="p">()</span> <span class="p">{</span>
        <span class="nn">MessageBody</span><span class="p">::</span><span class="n">Echo</span> <span class="p">{</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="k">self</span><span class="nf">.handle_echo</span><span class="p">(</span><span class="n">message</span><span class="p">),</span>
        <span class="nn">MessageBody</span><span class="p">::</span><span class="n">Init</span> <span class="p">{</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">msg_id</span><span class="p">,</span> <span class="n">node_ids</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="c1">// Initialize the node</span>
            <span class="k">self</span><span class="py">.id</span> <span class="o">=</span> <span class="n">node_id</span><span class="p">;</span>
            <span class="k">self</span><span class="py">.node_ids</span> <span class="o">=</span> <span class="n">node_ids</span><span class="p">;</span>

            <span class="c1">// Send init_ok response</span>
            <span class="k">let</span> <span class="n">reply_message</span> <span class="o">=</span> <span class="n">Message</span> <span class="p">{</span>
                <span class="n">src</span><span class="p">:</span> <span class="k">self</span><span class="py">.id</span><span class="nf">.clone</span><span class="p">(),</span>
                <span class="n">dest</span><span class="p">:</span> <span class="n">message</span><span class="nf">.clone</span><span class="p">()</span><span class="py">.src</span><span class="p">,</span>
                <span class="n">body</span><span class="p">:</span> <span class="nn">MessageBody</span><span class="p">::</span><span class="n">InitOk</span> <span class="p">{</span>
                    <span class="n">in_reply_to</span><span class="p">:</span> <span class="n">msg_id</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">};</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nn">serde_json</span><span class="p">::</span><span class="nf">to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reply_message</span><span class="p">)</span><span class="o">?</span><span class="p">);</span>
            <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nn">serde_json</span><span class="p">::</span><span class="nf">to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reply_message</span><span class="p">)</span><span class="o">?</span><span class="p">);</span>

            <span class="nf">Ok</span><span class="p">(())</span>
        <span class="p">}</span>
        <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"Unhandled message type"</span><span class="p">);</span>
            <span class="nf">Ok</span><span class="p">(())</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>The handle_message message is what brings it all together. We check the message type. If it’s the init message, we send a <code class="language-plaintext highlighter-rouge">ok</code> response for init and initialize our node. Otherwise, we dispatch the message to a relevant message handler. As we can see in the case of the <code class="language-plaintext highlighter-rouge">echo</code> message:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">handle_echo</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">echo_in</span><span class="p">:</span> <span class="n">Message</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nn">MessageBody</span><span class="p">::</span><span class="n">Echo</span> <span class="p">{</span> <span class="n">msg_id</span><span class="p">,</span> <span class="n">echo</span> <span class="p">}</span> <span class="o">=</span> <span class="n">echo_in</span><span class="py">.body</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">reply_message</span> <span class="o">=</span> <span class="n">Message</span> <span class="p">{</span>
            <span class="n">src</span><span class="p">:</span> <span class="k">self</span><span class="py">.id</span><span class="nf">.clone</span><span class="p">(),</span>
            <span class="n">dest</span><span class="p">:</span> <span class="n">echo_in</span><span class="py">.src</span><span class="p">,</span>
            <span class="n">body</span><span class="p">:</span> <span class="nn">MessageBody</span><span class="p">::</span><span class="n">EchoOk</span> <span class="p">{</span>
                <span class="n">msg_id</span><span class="p">:</span> <span class="k">self</span><span class="nf">.get_next_message_id</span><span class="p">(),</span>
                <span class="n">in_reply_to</span><span class="p">:</span> <span class="n">msg_id</span><span class="p">,</span>
                <span class="n">echo</span><span class="p">,</span>
            <span class="p">},</span>
        <span class="p">};</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nn">serde_json</span><span class="p">::</span><span class="nf">to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reply_message</span><span class="p">)</span><span class="o">?</span><span class="p">);</span>
        <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nn">serde_json</span><span class="p">::</span><span class="nf">to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reply_message</span><span class="p">)</span><span class="o">?</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div> <p>Even though the message type can never be anything other that <code class="language-plaintext highlighter-rouge">MessageBody::Echo</code>, we still use it to cast the message (I guess this would’ve been better in C++, since we have two vtable lookups, one in handle_message and another in <code class="language-plaintext highlighter-rouge">handle_echo</code>).</p> <p>Testing this with maelstrom library, we can see everything works:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>./maelstrom/maelstrom <span class="nb">test</span> <span class="nt">-w</span> <span class="nb">echo</span> <span class="nt">--bin</span> target/release/gossiprs <span class="se">\</span>
    <span class="nt">--node-count</span> 1 <span class="nt">--time-limit</span> 10

...
... bunch of output
...

Everything looks good! ヽ<span class="o">(</span>‘ー<span class="sb">`</span><span class="o">)</span>ノ
</code></pre></div></div> <h2 id="improving-message-handling">Improving message handling:</h2> <p>Since the first message is always the <code class="language-plaintext highlighter-rouge">init</code> message, we can check to see if that is actually the case, and only process messages after the first one (since we might miss a <code class="language-plaintext highlighter-rouge">init</code> message, and reach an invalid node state).</p> <div class="language-patch highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gh">diff --git a/src/main.rs b/src/main.rs
index 8cb2685..434d943 100644
</span><span class="gd">--- a/src/main.rs
</span><span class="gi">+++ b/src/main.rs
</span><span class="p">@@ -6,6 +6,7 @@</span> use std::io::stdin;
 mod message;
 
 #[derive(Debug, Default, Clone)]
<span class="gi">+#[allow(unused)]
</span> struct Node {
     id: String,
     node_ids: Vec&lt;String&gt;,
<span class="p">@@ -44,27 +45,26 @@</span> impl Node {
         Ok(())
     }
 
<span class="gi">+    fn handle_init(&amp;mut self, msg_id: i32, src: String) -&gt; Result&lt;()&gt; {
+        // Send init_ok response
+        let reply_message = Message {
+            src: self.id.clone(),
+            dest: src,
+            body: MessageBody::InitOk {
+                in_reply_to: msg_id,
+            },
+        };
+        println!("{}", serde_json::to_string(&amp;reply_message)?);
+        eprintln!("{}", serde_json::to_string(&amp;reply_message)?);
+
+        Ok(())
+    }
+
</span>     fn handle_message(&amp;mut self, message: Message) -&gt; Result&lt;()&gt; {
         match message.body.clone() {
             MessageBody::Echo { .. } =&gt; self.handle_echo(message),
<span class="gd">-            MessageBody::Init { node_id, msg_id, node_ids } =&gt; {
-                // Initialize the node
-                self.id = node_id;
-                self.node_ids = node_ids;
-
-                // Send init_ok response
-                let reply_message = Message {
-                    src: self.id.clone(),
-                    dest: message.clone().src,
-                    body: MessageBody::InitOk {
-                        in_reply_to: msg_id,
-                    },
-                };
-                println!("{}", serde_json::to_string(&amp;reply_message)?);
-                eprintln!("{}", serde_json::to_string(&amp;reply_message)?);
</span><span class="gi">+            MessageBody::Init { msg_id, .. } =&gt; self.handle_init(msg_id, message.src.clone()),
</span> 
<span class="gd">-                Ok(())
-            }
</span>             _ =&gt; {
                 eprintln!("Unhandled message type");
                 Ok(())
<span class="p">@@ -76,26 +76,38 @@</span> impl Node {
 #[tokio::main]
 async fn main() -&gt; Result&lt;()&gt; {
     let mut buffer = String::new();
<span class="gd">-    let mut node: Node = Default::default();
</span> 
<span class="gd">-    loop {
-        buffer.clear();
-        let len = stdin().read_line(&amp;mut buffer)?;
-        if len == 0 {
-            break;
-        }
</span><span class="gi">+    stdin().read_line(&amp;mut buffer)?;
+    let message: Message = serde_json::from_str(&amp;buffer)?;
+
+    if let MessageBody::Init {
+        node_id, node_ids, ..
+    } = message.body
+    {
+        let mut node: Node = Node::new(node_id, node_ids);
+        node.handle_message(serde_json::from_str(&amp;buffer)?)?;
</span> 
<span class="gd">-        let message: Message = match serde_json::from_str(&amp;buffer) {
-            Ok(msg) =&gt; msg,
-            Err(e) =&gt; {
-                eprintln!("Error parsing message: {}", e);
-                continue;
</span><span class="gi">+        loop {
+            buffer.clear();
+            let len = stdin().read_line(&amp;mut buffer)?;
+            if len == 0 {
+                break;
</span>             }
<span class="gd">-        };
</span> 
<span class="gd">-        if let Err(e) = node.handle_message(message) {
-            eprintln!("Error handling message: {}", e);
</span><span class="gi">+            let message: Message = match serde_json::from_str(&amp;buffer) {
+                Ok(msg) =&gt; msg,
+                Err(e) =&gt; {
+                    eprintln!("Error parsing message: {}", e);
+                    continue;
+                }
+            };
+
+            if let Err(e) = node.handle_message(message) {
+                eprintln!("Error handling message: {}", e);
+            }
</span>         }
<span class="gi">+    } else {
+        panic!("Expected first messaage to be a init message");
</span>     }
 
     Ok(())
</code></pre></div></div> <h2 id="handling-unique-ids">Handling unique IDs</h2> <p>The next part of the challenge is to handle unique ID generation. For that, we will introduce the required message types to our <code class="language-plaintext highlighter-rouge">Message</code> struct, and store an internal counter in the Node. Also, we improve “responding” by sending out messages on <code class="language-plaintext highlighter-rouge">stdout</code> <em>and</em> logging our progress on <code class="language-plaintext highlighter-rouge">stderr</code>. The majority of the work is done in the <code class="language-plaintext highlighter-rouge">handle_generate</code> function as listed below:</p> <div class="language-patch highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gh">diff --git a/src/main.rs b/src/main.rs
index 434d943..772c545 100644
</span><span class="gd">--- a/src/main.rs
</span><span class="gi">+++ b/src/main.rs
</span><span class="p">@@ -1,14 +1,18 @@</span>
 use anyhow::Result;
 use message::{Message, MessageBody};
 use serde_json;
<span class="gd">-use std::io::stdin;
</span><span class="gi">+use std::{
+    io::{stdin, Write},
+    sync::atomic::AtomicUsize,
+};
</span> 
 mod message;
 
<span class="gd">-#[derive(Debug, Default, Clone)]
</span><span class="gi">+#[derive(Debug)]
</span> #[allow(unused)]
 struct Node {
     id: String,
<span class="gi">+    counter: AtomicUsize,
</span>     node_ids: Vec&lt;String&gt;,
     current_msg_id: i32,
 }
<span class="p">@@ -16,6 +20,7 @@</span> struct Node {
 impl Node {
     fn new(id: String, node_ids: Vec&lt;String&gt;) -&gt; Self {
         Node {
<span class="gi">+            counter: AtomicUsize::new(0),
</span>             id,
             node_ids,
             current_msg_id: 0,
<span class="p">@@ -54,16 +59,45 @@</span> impl Node {
                 in_reply_to: msg_id,
             },
         };
<span class="gd">-        println!("{}", serde_json::to_string(&amp;reply_message)?);
-        eprintln!("{}", serde_json::to_string(&amp;reply_message)?);
</span> 
<span class="gd">-        Ok(())
</span><span class="gi">+        self.write_and_log_response(reply_message)
+    }
+
+    fn handle_generate(&amp;mut self, message: Message) -&gt; Result&lt;()&gt; {
+        // Generate a unique ID and send back to the receiver.
+        // To generate a unique ID, we will take the instant value in self,
+        // and just return the number of millis passed.
+
+        Ok(if let MessageBody::Generate { msg_id } = message.body {
+            let reply_message = Message {
+                src: self.id.clone(),
+                dest: message.src,
+                body: MessageBody::GenerateOk {
+                    id: format!(
+                        "{}-{}",
+                        self.id,
+                        self.counter
+                            .fetch_add(1, std::sync::atomic::Ordering::SeqCst)
+                    ),
+                    msg_id: self.get_next_message_id(),
+                    in_reply_to: msg_id,
+                },
+            };
+
+            self.write_and_log_response(reply_message)?
+        } else {
+            ()
+        })
</span>     }
 
     fn handle_message(&amp;mut self, message: Message) -&gt; Result&lt;()&gt; {
<span class="gi">+        let converted = serde_json::to_string(&amp;message)?;
+        eprintln!("Received request: {}", converted);
+
</span>         match message.body.clone() {
             MessageBody::Echo { .. } =&gt; self.handle_echo(message),
             MessageBody::Init { msg_id, .. } =&gt; self.handle_init(msg_id, message.src.clone()),
<span class="gi">+            MessageBody::Generate { .. } =&gt; self.handle_generate(message),
</span> 
             _ =&gt; {
                 eprintln!("Unhandled message type");
<span class="p">@@ -71,6 +105,13 @@</span> impl Node {
             }
         }
     }
<span class="gi">+
+    fn write_and_log_response(&amp;self, message: Message) -&gt; Result&lt;()&gt; {
+        let converted = serde_json::to_string(&amp;message)?;
+        println!("{}", converted);
+        eprint!("Responding: {}", converted);
+        Ok(std::io::stdout().flush()?)
+    }
</span> }
 
 #[tokio::main]
<span class="gh">diff --git a/src/message.rs b/src/message.rs
index 6c79550..01adec1 100644
</span><span class="gd">--- a/src/message.rs
</span><span class="gi">+++ b/src/message.rs
</span><span class="p">@@ -20,6 +20,7 @@</span> pub enum MessageBody {
         in_reply_to: i32,
         echo: String,
     },
<span class="gi">+
</span>     Init {
         msg_id: i32,
         node_id: String,
<span class="p">@@ -28,4 +29,14 @@</span> pub enum MessageBody {
     InitOk {
         in_reply_to: i32,
     },
<span class="gi">+
+    Generate {
+        msg_id: i32
+    },
+
+    GenerateOk {
+        id: String,
+        msg_id: i32,
+        in_reply_to: i32
+    },
</span> }
</code></pre></div></div> <h2 id="the-fun-begins">The fun begins!</h2> <p>Now the actual fun begins. We will implement methods to handle broadcast, and forward it to our peers.</p> <div class="language-patch highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gh">diff --git a/src/main.rs b/src/main.rs
index 772c545..7b19426 100644
</span><span class="gd">--- a/src/main.rs
</span><span class="gi">+++ b/src/main.rs
</span><span class="p">@@ -2,6 +2,7 @@</span> use anyhow::Result;
 use message::{Message, MessageBody};
 use serde_json;
 use std::{
<span class="gi">+    collections::HashSet,
</span> };
<span class="p">@@ -14,6 +15,7 @@</span> struct Node {
     id: String,
<span class="gi">+    values: HashSet&lt;i32&gt;,
</span>     current_msg_id: i32,
 }
 
<span class="p">@@ -24,6 +26,7 @@</span> impl Node {
             id,
<span class="gi">+            values: HashSet::new(),
</span>         }
     }
<span class="err">
</span><span class="gi">+    fn handle_broadcast(&amp;mut self, message: Message) -&gt; Result&lt;()&gt; {
+        if let MessageBody::Broadcast {
+            msg_id,
+            message: value,
+        } = message.body
+        {
+            self.values.insert(value);
+            let reply = Message {
+                src: self.id.clone(),
+                dest: message.src,
+                body: MessageBody::BroadcastOk {
+                    in_reply_to: msg_id,
+                    msg_id: self.get_next_message_id(),
+                },
+            };
+
+            self.write_and_log_response(reply)
+        } else {
+            Ok(())
+        }
+    }
+
+    fn handle_read(&amp;mut self, message: Message) -&gt; Result&lt;()&gt; {
+        if let MessageBody::Read { msg_id } = message.body {
+            let messages: HashSet&lt;i32&gt; = self.values.clone();
+            let reply = Message {
+                src: self.id.clone(),
+                dest: message.src,
+                body: MessageBody::ReadOk {
+                    messages,
+                    in_reply_to: msg_id,
+                },
+            };
+
+            self.write_and_log_response(reply)
+        } else {
+            Ok(())
+        }
+    }
+
+    fn handle_topology(&amp;mut self, message: Message) -&gt; Result&lt;()&gt; {
+        if let MessageBody::Topology { msg_id, .. } = message.body {
+            let reply = Message {
+                src: self.id.clone(),
+                dest: message.src,
+                body: MessageBody::TopologyOk {
+                    in_reply_to: msg_id,
+                },
+            };
+
+            self.write_and_log_response(reply)
+        } else {
+            Ok(())
+        }
+    }
+
</span>     fn handle_message(&amp;mut self, message: Message) -&gt; Result&lt;()&gt; {
         let converted = serde_json::to_string(&amp;message)?;
         eprintln!("Received request: {}", converted);
<span class="p">@@ -98,6 +157,9 @@</span> impl Node {
             MessageBody::Echo { .. } =&gt; self.handle_echo(message),
<span class="gi">+            MessageBody::Broadcast { .. } =&gt; self.handle_broadcast(message),
+            MessageBody::Read { .. } =&gt; self.handle_read(message),
+            MessageBody::Topology { .. } =&gt; self.handle_topology(message),
</span> 
             _ =&gt; {
                 eprintln!("Unhandled message type");
<span class="gh">diff --git a/src/message.rs b/src/message.rs
index 01adec1..7dd52b7 100644
</span><span class="gd">--- a/src/message.rs
</span><span class="gi">+++ b/src/message.rs
</span><span class="p">@@ -1,3 +1,5 @@</span>
<span class="gi">+use std::collections::{HashMap, HashSet};
+
</span> #[derive(Debug, Serialize, Deserialize, Clone)]
<span class="p">@@ -39,4 +41,32 @@</span> pub enum MessageBody {
<span class="gi">+    Broadcast {
+        msg_id: i32,
+        message: i32
+    },
+
+    BroadcastOk {
+        in_reply_to: i32,
+        msg_id: i32
+    },
+
+    Read {
+        msg_id: i32,
+    },
+
+    ReadOk {
+        messages: HashSet&lt;i32&gt;,
+        in_reply_to: i32
+    },
+
+    Topology {
+        msg_id: i32,
+        topology: HashMap&lt;String, Vec&lt;String&gt;&gt;
+    },
+
+    TopologyOk {
+        in_reply_to: i32
+    }
</span> }
</code></pre></div></div> <p>For this, we need to implement handlers for <code class="language-plaintext highlighter-rouge">read</code>, <code class="language-plaintext highlighter-rouge">topology</code>, and <code class="language-plaintext highlighter-rouge">broadcast</code> messages as listed in the outline. The logic itself is super simple; we store all the IDs we’ve seen in a <code class="language-plaintext highlighter-rouge">HashSet</code>, and return the hashset when <code class="language-plaintext highlighter-rouge">read</code> is invoked on our node.</p> <h2 id="talking-to-other-nodes">Talking to other nodes</h2> <p>The next patch will implement a way to talk to other nodes, whatever is connected to ours.</p> <div class="language-patch highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gh">diff --git a/src/main.rs b/src/main.rs
index 7b19426..0f955b8 100644
</span><span class="gd">--- a/src/main.rs
</span><span class="gi">+++ b/src/main.rs
</span><span class="p">@@ -17,6 +17,8 @@</span> struct Node {
     node_ids: Vec&lt;String&gt;,
     values: HashSet&lt;i32&gt;,
     current_msg_id: i32,
<span class="gi">+    neighbors: Vec&lt;String&gt;,
+    downstream: Vec&lt;String&gt;,
</span> }
 
 impl Node {
<span class="p">@@ -27,6 +29,8 @@</span> impl Node {
             node_ids,
             current_msg_id: 0,
             values: HashSet::new(),
<span class="gi">+            neighbors: Vec::new(),
+            downstream: Vec::new(),
</span>         }
     }
 
<span class="p">@@ -99,7 +103,7 @@</span> impl Node {
             message: value,
         } = message.body
         {
<span class="gd">-            self.values.insert(value);
</span><span class="gi">+            // First, respond that I got this value.
</span>             let reply = Message {
                 src: self.id.clone(),
                 dest: message.src,
<span class="p">@@ -109,7 +113,65 @@</span> impl Node {
                 },
             };
 
<span class="gd">-            self.write_and_log_response(reply)
</span><span class="gi">+            self.write_and_log_response(reply)?;
+
+            let i_have_this = self.values.contains(&amp;value);
+            if !i_have_this {
+                self.values.insert(value);
+
+                // Tell my friends about this too!. Write Gossip messages.
+                let neighbors = self.neighbors.clone();
+                for neighbor in neighbors {
+                    let new_msg_id = self.get_next_message_id();
+
+                    let gossip = Message {
+                        src: self.id.clone(),
+                        dest: neighbor.clone(),
+                        body: MessageBody::Gossip {
+                            msg_id: new_msg_id,
+                            gossip_value: value,
+                        },
+                    };
+
+                    self.write_and_log_response(gossip)?;
+                }
+            }
+
+            Ok(())
+        } else {
+            Ok(())
+        }
+    }
+
+    fn handle_gossip(&amp;mut self, message: Message) -&gt; Result&lt;()&gt; {
+        if let MessageBody::Gossip {
+            gossip_value: value,
+            ..
+        } = message.body
+        {
+            let i_have_this = self.values.contains(&amp;value);
+            if !i_have_this {
+                self.values.insert(value);
+
+                // Tell my friends about this too!. Write Gossip messages.
+                let neighbors = self.neighbors.clone();
+                for neighbor in neighbors {
+                    let new_msg_id = self.get_next_message_id();
+
+                    let gossip = Message {
+                        src: self.id.clone(),
+                        dest: neighbor.clone(),
+                        body: MessageBody::Gossip {
+                            msg_id: new_msg_id,
+                            gossip_value: value,
+                        },
+                    };
+
+                    self.write_and_log_response(gossip)?;
+                }
+            }
+
+            Ok(())
</span>         } else {
             Ok(())
         }
<span class="p">@@ -134,7 +196,21 @@</span> impl Node {
     }
 
     fn handle_topology(&amp;mut self, message: Message) -&gt; Result&lt;()&gt; {
<span class="gd">-        if let MessageBody::Topology { msg_id, .. } = message.body {
</span><span class="gi">+        if let MessageBody::Topology {
+            msg_id,
+            topology: graph,
+        } = message.body
+        {
+            self.neighbors = graph
+                .get(&amp;self.id)
+                .expect("No neighbors defined for me? Empty??")
+                .clone();
+
+            // Something fancy. Do some graph computation to find downstream nodes? Nah.
+            // Maybe in 3.d.
+
+            self.downstream.extend(self.neighbors.clone());
+
</span>             let reply = Message {
                 src: self.id.clone(),
                 dest: message.src,
<span class="p">@@ -160,6 +236,7 @@</span> impl Node {
             MessageBody::Broadcast { .. } =&gt; self.handle_broadcast(message),
             MessageBody::Read { .. } =&gt; self.handle_read(message),
             MessageBody::Topology { .. } =&gt; self.handle_topology(message),
<span class="gi">+            MessageBody::Gossip { .. } =&gt; self.handle_gossip(message),
</span> 
             _ =&gt; {
                 eprintln!("Unhandled message type");
<span class="gh">diff --git a/src/message.rs b/src/message.rs
index 7dd52b7..1748ee8 100644
</span><span class="gd">--- a/src/message.rs
</span><span class="gi">+++ b/src/message.rs
</span><span class="p">@@ -68,5 +68,12 @@</span> pub enum MessageBody {
 
     TopologyOk {
         in_reply_to: i32
<span class="gd">-    }
</span><span class="gi">+    },
+
+    // Custom message types:
+
+    Gossip {
+        msg_id: i32,
+        gossip_value: i32
+    },
</span> }
</code></pre></div></div> <p>The logic is simple:</p> <ul> <li>We <code class="language-plaintext highlighter-rouge">Gossip</code> our message to our peers when we receive a gossip message. Before doing that, we acknowledge the gossip.</li> <li>The <code class="language-plaintext highlighter-rouge">GossipAck</code> message is sent to the sender to make sure they don’t re-send the gossip again (this comes in a later part).</li> </ul> <p>If we do not respond before updating our state, we will fall into an infinite loop where we forward the message, receive it, and keep forwarding it. So, we first ack the message, and <em>then</em> forward it to the neighbors.</p> <h2 id="sending-message-with-retries">Sending message with Retries</h2> <p>The current method implements ways to send message, but we do not retry if it fails. Since we don’t have the privilege of using <code class="language-plaintext highlighter-rouge">SyncRPC</code> that is in the go library, we need to implement our own. The go library uses <code class="language-plaintext highlighter-rouge">Context</code> with <code class="language-plaintext highlighter-rouge">Cancel</code>, and something similar that can be implemented in Rust is a <code class="language-plaintext highlighter-rouge">oneshot_channel</code>. For every message we expect to receive a reply to, we store a <code class="language-plaintext highlighter-rouge">oneshot</code> channel, which is keyed on the message id. If we receive any message whose <code class="language-plaintext highlighter-rouge">in_reply_to</code> field has that particular message id, we pop the channel, and cancel our timeout.</p> <div class="language-patch highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gh">diff --git a/src/main.rs b/src/main.rs
index 0f955b8..b61487b 100644
</span><span class="gd">--- a/src/main.rs
</span><span class="gi">+++ b/src/main.rs
</span><span class="p">@@ -2,10 +2,12 @@</span> use anyhow::Result;
 use message::{Message, MessageBody};
 use serde_json;
 use std::{
<span class="gd">-    collections::HashSet,
</span><span class="gi">+    collections::{HashMap, HashSet},
</span>     io::{stdin, Write},
     sync::atomic::AtomicUsize,
<span class="gi">+    time::Duration,
</span> };
<span class="gi">+use tokio::{runtime::Runtime, time};
</span> 
 mod message;
 
<span class="p">@@ -13,24 +15,28 @@</span> mod message;
 #[allow(unused)]
 struct Node {
     id: String,
<span class="gi">+    runtime: Runtime,
</span>     counter: AtomicUsize,
     node_ids: Vec&lt;String&gt;,
     values: HashSet&lt;i32&gt;,
     current_msg_id: i32,
     neighbors: Vec&lt;String&gt;,
     downstream: Vec&lt;String&gt;,
<span class="gi">+    ack_channels: HashMap&lt;i32, tokio::sync::oneshot::Sender&lt;i32&gt;&gt;,
</span> }
 
 impl Node {
     fn new(id: String, node_ids: Vec&lt;String&gt;) -&gt; Self {
         Node {
             counter: AtomicUsize::new(0),
<span class="gi">+            runtime: Runtime::new().unwrap(),
</span>             id,
             node_ids,
             current_msg_id: 0,
             values: HashSet::new(),
             neighbors: Vec::new(),
             downstream: Vec::new(),
<span class="gi">+            ack_channels: HashMap::new(),
</span>         }
     }
 
<span class="p">@@ -51,8 +57,8 @@</span> impl Node {
                     echo,
                 },
             };
<span class="gd">-            println!("{}", serde_json::to_string(&amp;reply_message)?);
-            eprintln!("{}", serde_json::to_string(&amp;reply_message)?);
</span><span class="gi">+
+            self.write_and_log_response(reply_message)?;
</span>         }
         Ok(())
     }
<span class="p">@@ -238,6 +244,19 @@</span> impl Node {
             MessageBody::Topology { .. } =&gt; self.handle_topology(message),
             MessageBody::Gossip { .. } =&gt; self.handle_gossip(message),
 
<span class="gi">+            MessageBody::GossipAck {
+                in_reply_to,
+                msg_id,
+            } =&gt; {
+                // Check that we have the channel to send the ack.
+                if let Some(sender) = self.ack_channels.remove(&amp;in_reply_to) {
+                    Ok(sender.send(msg_id).unwrap())
+                } else {
+                    eprintln!("No channel found to send ack");
+                    Ok(())
+                }
+            }
+
</span>             _ =&gt; {
                 eprintln!("Unhandled message type");
                 Ok(())
<span class="p">@@ -245,11 +264,39 @@</span> impl Node {
         }
     }
 
<span class="gd">-    fn write_and_log_response(&amp;self, message: Message) -&gt; Result&lt;()&gt; {
-        let converted = serde_json::to_string(&amp;message)?;
-        println!("{}", converted);
-        eprint!("Responding: {}", converted);
-        Ok(std::io::stdout().flush()?)
</span><span class="gi">+    fn write_and_log_response(&amp;mut self, message: Message) -&gt; Result&lt;()&gt; {
+        if let MessageBody::Gossip { msg_id, .. } = &amp;message.body {
+            let (sender, mut receiver) = tokio::sync::oneshot::channel::&lt;i32&gt;();
+            self.ack_channels.insert(*msg_id, sender);
+
+            // Try to send the message to the receiver, wait for a certain time, and send the message
+            // again if we do not get the response back. Do all this within a tokio runtime.
+            let fut = async move {
+                let converted = serde_json::to_string(&amp;message).unwrap();
+                println!("{}", converted);
+                let mut ticker = time::interval(Duration::from_millis(100));
+
+                loop {
+                    tokio::select! {
+                        _ = ticker.tick() =&gt; {
+                            // Resend the message; we have no acks yet.
+                            println!("{}", converted.clone());
+                        }
+                        _ = &amp;mut receiver =&gt; {
+                            // We got an ack! Break the loop.
+                            break
+                        }
+                    }
+                }
+            };
+
+            self.runtime.spawn(fut);
+            Ok(())
+        } else {
+            println!("{}", serde_json::to_string(&amp;message)?);
+            eprint!("Responding: {}", serde_json::to_string(&amp;message)?);
+            Ok(std::io::stdout().flush()?)
+        }
</span>     }
 }
 
<span class="gh">diff --git a/src/message.rs b/src/message.rs
index 1748ee8..d331470 100644
</span><span class="gd">--- a/src/message.rs
</span><span class="gi">+++ b/src/message.rs
</span><span class="p">@@ -76,4 +76,9 @@</span> pub enum MessageBody {
         msg_id: i32,
         gossip_value: i32
     },
<span class="gi">+
+    GossipAck {
+        in_reply_to: i32,
+        msg_id: i32
+    }
</span> }
</code></pre></div></div> <p>In order to implement this, we create a <code class="language-plaintext highlighter-rouge">Tokio</code> runtime, and push futures that are polling the stdin, looking for messages we have replies to, or waiting on a timer, which fires every 100ms. Either the message reply arrives, or the timer expires, when we resend the message. Since we are only looking for replies (confirmation) to the Gossip messages, we match the message type on message send. The future is created only if the message type matches Gossip message. The modification to handling gossip is simple enough:</p> <div class="language-patch highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gh">diff --git a/src/main.rs b/src/main.rs
index b61487b..ab1b253 100644
</span><span class="gd">--- a/src/main.rs
</span><span class="gi">+++ b/src/main.rs
</span><span class="p">@@ -152,9 +152,21 @@</span> impl Node {
     fn handle_gossip(&amp;mut self, message: Message) -&gt; Result&lt;()&gt; {
         if let MessageBody::Gossip {
             gossip_value: value,
<span class="gd">-            ..
</span><span class="gi">+            msg_id
</span>         } = message.body
         {
<span class="gi">+            // First, respond that I got this value.
+            let reply = Message {
+                src: self.id.clone(),
+                dest: message.src,
+                body: MessageBody::GossipAck {
+                    in_reply_to: msg_id,
+                    msg_id: self.get_next_message_id(),
+                },
+            };
+
+            self.write_and_log_response(reply)?;
+
</span>             let i_have_this = self.values.contains(&amp;value);
             if !i_have_this {
                 self.values.insert(value);
</code></pre></div></div> <h2 id="latency-constraints">Latency constraints.</h2> <p>This is the part I had the most fun with while completing the first part of this challenge. You are supposed to send messages with 400ms latency medians (600ms max latency). The constraints are:</p> <ul> <li>30 message-per-op</li> <li>400ms median latency</li> <li>600ms max latency</li> </ul> <p>given that every message has 100ms latency within the system. This means, we need to optimize our graph in some way. In a overkill fashion, I decided to write a genetic algorithm to generate the graph.</p> <h3 id="genetic-algorithm-for-graph-generation">Genetic Algorithm for graph generation.</h3> <p>The graph will be encoded in the following way:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">random</span>
<span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Self</span>
<span class="kn">import</span> <span class="n">networkx</span> <span class="k">as</span> <span class="n">nx</span>
<span class="kn">import</span> <span class="n">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="n">NUM_NODES_FIXED</span> <span class="o">=</span> <span class="mi">25</span>
<span class="n">POPULATION_SIZE</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">MAX_ITERATIONS</span>  <span class="o">=</span> <span class="mi">500</span>
<span class="n">MAX_PERMISSIBLE_PATH_LENGTH</span> <span class="o">=</span> <span class="mi">6</span>

<span class="k">class</span> <span class="nc">Graph</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">num_nodes</span> <span class="o">=</span> <span class="mi">25</span><span class="p">,</span> <span class="n">max_permissible_path_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">self</span><span class="p">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_nodes</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">max_permissible_path_length</span> <span class="o">=</span> <span class="n">max_permissible_path_length</span>
        <span class="n">self</span><span class="p">.</span><span class="n">edges</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">from_vertex</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">to_vertex</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="nf">if </span><span class="p">(</span><span class="n">from_vertex</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">vertices</span> <span class="ow">or</span> <span class="n">to_vertex</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">vertices</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">self</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">from_vertex</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">edges</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">from_vertex</span><span class="p">,</span> <span class="p">[])</span> <span class="ow">or</span> <span class="p">[]</span>
        <span class="n">self</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">to_vertex</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">edges</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">to_vertex</span><span class="p">,</span> <span class="p">[])</span> <span class="ow">or</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">to_vertex</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">from_vertex</span><span class="p">]:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">from_vertex</span><span class="p">].</span><span class="nf">append</span><span class="p">(</span><span class="n">to_vertex</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">to_vertex</span><span class="p">].</span><span class="nf">append</span><span class="p">(</span><span class="n">from_vertex</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_distances</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">from_vertex</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nf">set</span><span class="p">()</span>

        <span class="n">queue</span> <span class="o">=</span> <span class="p">[(</span><span class="n">from_vertex</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
        <span class="n">distances</span><span class="p">[</span><span class="n">from_vertex</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">visited</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">from_vertex</span><span class="p">)</span>

        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">first</span><span class="p">,</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">edges</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="p">[])</span>
            <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                    <span class="n">visited</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
                    <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">neighbor</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="n">distances</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">=</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">distances</span>

    <span class="k">def</span> <span class="nf">get_nodes_count</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">vertices</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">check_average_propagation_cost</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="n">score</span> <span class="o">=</span> <span class="mi">0</span>
         
        <span class="n">disconnected_nodes</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">nodes_with_maxpath_violations</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">max_edges</span> <span class="o">=</span> <span class="nf">max </span><span class="p">([</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">edges</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="p">[]))</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">vertices</span> <span class="p">])</span>
        <span class="n">total_edges</span> <span class="o">=</span> <span class="nf">sum</span><span class="p">([</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">edges</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="p">[]))</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">vertices</span> <span class="p">])</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">vertices</span><span class="p">:</span>
            <span class="n">distances</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">get_distances</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">disconnected_nodes</span> <span class="o">+=</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">vertices</span><span class="p">)</span> <span class="o">-</span> <span class="nf">len</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span> <span class="c1"># Calculate the number of nodes unreachable from this
</span>            <span class="n">nodes_with_maxpath_violations</span> <span class="o">+=</span> <span class="nf">len</span><span class="p">([</span><span class="n">tonode</span> <span class="k">for</span> <span class="n">tonode</span> <span class="ow">in</span> <span class="n">distances</span> <span class="k">if</span> <span class="n">distances</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">tonode</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">MAX_PERMISSIBLE_PATH_LENGTH</span> <span class="p">])</span>

        <span class="n">score</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">100000</span> <span class="o">*</span> <span class="n">disconnected_nodes</span> <span class="c1"># All nodes MUST be connected
</span>        <span class="n">score</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">100000</span> <span class="o">*</span> <span class="n">nodes_with_maxpath_violations</span>
        <span class="n">score</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">2000</span> <span class="o">*</span> <span class="n">max_edges</span>
        <span class="n">score</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">250</span> <span class="o">*</span> <span class="n">total_edges</span>

        <span class="k">return</span> <span class="n">score</span>
</code></pre></div></div> <p>The functions are pretty self-explanatory:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">get_nodes_count</code> returns the number of nodes in the graph.</li> <li> <code class="language-plaintext highlighter-rouge">check_average_propagation_cost</code> returns the score of the graph. The score is calculated as: <ul> <li>100000 * disconnected_nodes: All nodes must be connected.</li> <li>100000 * nodes_with_maxpath_violations: No node should have a path length greater than 6.</li> <li>2000 * max_edges: The maximum number of edges in the graph.</li> <li>250 * total_edges: The total number of edges in the graph.</li> </ul> </li> <li> <code class="language-plaintext highlighter-rouge">get_distances</code> returns the distances from a node to all other nodes in the graph.</li> <li> <code class="language-plaintext highlighter-rouge">add_edge</code> adds an edge between two nodes. The edges are bidirectional.</li> <li> <code class="language-plaintext highlighter-rouge">__init__</code> initializes the graph.</li> </ul> <p>Using this, and implementing a simple genetic algorithm, we land with a graph that looks like this:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">"n17"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n19"</span><span class="p">,</span> <span class="s">"n0"</span><span class="p">],</span>
<span class="s">"n19"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n17"</span><span class="p">,</span> <span class="s">"n14"</span><span class="p">],</span>
<span class="s">"n10"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n2"</span><span class="p">,</span> <span class="s">"n22"</span><span class="p">,</span> <span class="s">"n20"</span><span class="p">],</span>
<span class="s">"n2"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n10"</span><span class="p">,</span> <span class="s">"n13"</span><span class="p">,</span> <span class="s">"n11"</span><span class="p">],</span>
<span class="s">"n13"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n2"</span><span class="p">,</span> <span class="s">"n15"</span><span class="p">],</span>
<span class="s">"n7"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n14"</span><span class="p">,</span> <span class="s">"n3"</span><span class="p">],</span>
<span class="s">"n14"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n7"</span><span class="p">,</span> <span class="s">"n19"</span><span class="p">,</span> <span class="s">"n12"</span><span class="p">],</span>
<span class="s">"n24"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n22"</span><span class="p">,</span> <span class="s">"n1"</span><span class="p">,</span> <span class="s">"n23"</span><span class="p">],</span>
<span class="s">"n22"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n24"</span><span class="p">,</span> <span class="s">"n10"</span><span class="p">,</span> <span class="s">"n8"</span><span class="p">],</span>
<span class="s">"n18"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n5"</span><span class="p">,</span> <span class="s">"n15"</span><span class="p">],</span>
<span class="s">"n5"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n18"</span><span class="p">,</span> <span class="s">"n0"</span><span class="p">,</span> <span class="s">"n3"</span><span class="p">],</span>
<span class="s">"n0"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n4"</span><span class="p">,</span> <span class="s">"n17"</span><span class="p">,</span> <span class="s">"n5"</span><span class="p">],</span>
<span class="s">"n4"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n0"</span><span class="p">,</span> <span class="s">"n8"</span><span class="p">],</span>
<span class="s">"n1"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n24"</span><span class="p">,</span> <span class="s">"n6"</span><span class="p">,</span> <span class="s">"n11"</span><span class="p">],</span>
<span class="s">"n23"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n24"</span><span class="p">,</span> <span class="s">"n6"</span><span class="p">,</span> <span class="s">"n16"</span><span class="p">],</span>
<span class="s">"n21"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n20"</span><span class="p">,</span> <span class="s">"n12"</span><span class="p">,</span> <span class="s">"n9"</span><span class="p">],</span>
<span class="s">"n20"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n21"</span><span class="p">,</span> <span class="s">"n9"</span><span class="p">,</span> <span class="s">"n10"</span><span class="p">],</span>
<span class="s">"n15"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n13"</span><span class="p">,</span> <span class="s">"n12"</span><span class="p">,</span> <span class="s">"n18"</span><span class="p">],</span>
<span class="s">"n6"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n1"</span><span class="p">,</span> <span class="s">"n23"</span><span class="p">,</span> <span class="s">"n3"</span><span class="p">],</span>
<span class="s">"n12"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n21"</span><span class="p">,</span> <span class="s">"n14"</span><span class="p">,</span> <span class="s">"n15"</span><span class="p">],</span>
<span class="s">"n9"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n21"</span><span class="p">,</span> <span class="s">"n20"</span><span class="p">],</span>
<span class="s">"n11"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n2"</span><span class="p">,</span> <span class="s">"n1"</span><span class="p">],</span>
<span class="s">"n3"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n7"</span><span class="p">,</span> <span class="s">"n6"</span><span class="p">,</span> <span class="s">"n5"</span><span class="p">],</span>
<span class="s">"n8"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n4"</span><span class="p">,</span> <span class="s">"n16"</span><span class="p">,</span> <span class="s">"n22"</span><span class="p">],</span>
<span class="s">"n16"</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"n23"</span><span class="p">,</span> <span class="s">"n8"</span><span class="p">],</span>

</code></pre></div></div> <p>Instead of using the given topology, this is the topology we can use. With this, we get the following results on median:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>latencies:
0.5<span class="o">=</span>434, 1:599

msg-per-op:
29
</code></pre></div></div> <p>The genetic algorithm is as follows:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Chromosome</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">self</span><span class="p">.</span><span class="n">graph</span> <span class="o">=</span> <span class="nc">Graph</span><span class="p">(</span><span class="n">num_nodes</span><span class="o">=</span><span class="n">NUM_NODES_FIXED</span><span class="p">,</span> <span class="n">max_permissible_path_length</span><span class="o">=</span><span class="n">MAX_PERMISSIBLE_PATH_LENGTH</span><span class="p">)</span>
        <span class="c1"># Initialize some random connections
</span>        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">50</span><span class="p">)):</span>
            <span class="n">from_node</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">NUM_NODES_FIXED</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">to_node</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">NUM_NODES_FIXED</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">from_node</span> <span class="o">!=</span> <span class="n">to_node</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">add_edge</span><span class="p">(</span><span class="n">from_node</span><span class="p">,</span> <span class="n">to_node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">mutate</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
        <span class="sh">"""</span><span class="s">
        Mutation strategies:
        1. Add a random edge
        2. Remove a random edge
        3. Rewire an existing edge
        </span><span class="sh">"""</span>
        <span class="n">mutation_type</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">choice</span><span class="p">([</span><span class="sh">'</span><span class="s">add</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">remove</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">rewire</span><span class="sh">'</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">mutation_type</span> <span class="o">==</span> <span class="sh">'</span><span class="s">add</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">from_node</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">NUM_NODES_FIXED</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">to_node</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">NUM_NODES_FIXED</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">from_node</span> <span class="o">!=</span> <span class="n">to_node</span> <span class="ow">and</span> <span class="n">to_node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">from_node</span><span class="p">,</span> <span class="p">[]):</span>
                <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">add_edge</span><span class="p">(</span><span class="n">from_node</span><span class="p">,</span> <span class="n">to_node</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">mutation_type</span> <span class="o">==</span> <span class="sh">'</span><span class="s">remove</span><span class="sh">'</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">:</span>
                <span class="n">from_node</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">choice</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">.</span><span class="nf">keys</span><span class="p">()))</span>
                <span class="n">to_node</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">choice</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">from_node</span><span class="p">])</span>
                <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">from_node</span><span class="p">].</span><span class="nf">remove</span><span class="p">(</span><span class="n">to_node</span><span class="p">)</span>
                <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">to_node</span><span class="p">].</span><span class="nf">remove</span><span class="p">(</span><span class="n">from_node</span><span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">from_node</span><span class="p">]:</span>
                    <span class="k">del</span> <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">from_node</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">to_node</span><span class="p">]:</span>
                    <span class="k">del</span> <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">to_node</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">mutation_type</span> <span class="o">==</span> <span class="sh">'</span><span class="s">rewire</span><span class="sh">'</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">:</span>
                <span class="n">from_node</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">choice</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">.</span><span class="nf">keys</span><span class="p">()))</span>
                <span class="n">old_to_node</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">choice</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">from_node</span><span class="p">])</span>
                <span class="n">new_to_node</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">NUM_NODES_FIXED</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

                <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">from_node</span><span class="p">].</span><span class="nf">remove</span><span class="p">(</span><span class="n">old_to_node</span><span class="p">)</span>
                <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">[</span><span class="n">old_to_node</span><span class="p">].</span><span class="nf">remove</span><span class="p">(</span><span class="n">from_node</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">new_to_node</span> <span class="o">!=</span> <span class="n">from_node</span> <span class="ow">and</span> <span class="n">new_to_node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">from_node</span><span class="p">,</span> <span class="p">[]):</span>
                    <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">add_edge</span><span class="p">(</span><span class="n">from_node</span><span class="p">,</span> <span class="n">new_to_node</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">self</span>

    <span class="k">def</span> <span class="nf">crossover</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="sh">"</span><span class="s">Chromosome</span><span class="sh">"</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="sh">"</span><span class="s">Chromosome</span><span class="sh">"</span><span class="p">]:</span>
        <span class="sh">"""</span><span class="s">
        Crossover strategies:
        1. Randomly combine edges from both parent chromosomes
        2. Create two offspring with mixed edge sets
        </span><span class="sh">"""</span>
        <span class="n">offspring1</span> <span class="o">=</span> <span class="nc">Chromosome</span><span class="p">()</span>
        <span class="n">offspring2</span> <span class="o">=</span> <span class="nc">Chromosome</span><span class="p">()</span>

        <span class="n">all_edges_parent1</span> <span class="o">=</span> <span class="nf">set</span><span class="p">()</span>
        <span class="n">all_edges_parent2</span> <span class="o">=</span> <span class="nf">set</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">from_node</span><span class="p">,</span> <span class="n">to_nodes</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">.</span><span class="nf">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">to_node</span> <span class="ow">in</span> <span class="n">to_nodes</span><span class="p">:</span>
                <span class="n">all_edges_parent1</span><span class="p">.</span><span class="nf">add</span><span class="p">((</span><span class="n">from_node</span><span class="p">,</span> <span class="n">to_node</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">from_node</span><span class="p">,</span> <span class="n">to_nodes</span> <span class="ow">in</span> <span class="n">other</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span><span class="p">.</span><span class="nf">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">to_node</span> <span class="ow">in</span> <span class="n">to_nodes</span><span class="p">:</span>
                <span class="n">all_edges_parent2</span><span class="p">.</span><span class="nf">add</span><span class="p">((</span><span class="n">from_node</span><span class="p">,</span> <span class="n">to_node</span><span class="p">))</span>

        <span class="n">combined_edges</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="n">all_edges_parent1</span><span class="p">.</span><span class="nf">union</span><span class="p">(</span><span class="n">all_edges_parent2</span><span class="p">))</span>
        <span class="n">random</span><span class="p">.</span><span class="nf">shuffle</span><span class="p">(</span><span class="n">combined_edges</span><span class="p">)</span>

        <span class="n">offspring1_edges</span> <span class="o">=</span> <span class="n">combined_edges</span><span class="p">[:</span><span class="nf">len</span><span class="p">(</span><span class="n">combined_edges</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">offspring2_edges</span> <span class="o">=</span> <span class="n">combined_edges</span><span class="p">[</span><span class="nf">len</span><span class="p">(</span><span class="n">combined_edges</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">:]</span>

        <span class="n">offspring1</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">offspring2</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="n">edges</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">from_node</span><span class="p">,</span> <span class="n">to_node</span> <span class="ow">in</span> <span class="n">offspring1_edges</span><span class="p">:</span>
            <span class="n">offspring1</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">add_edge</span><span class="p">(</span><span class="n">from_node</span><span class="p">,</span> <span class="n">to_node</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">from_node</span><span class="p">,</span> <span class="n">to_node</span> <span class="ow">in</span> <span class="n">offspring2_edges</span><span class="p">:</span>
            <span class="n">offspring2</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">add_edge</span><span class="p">(</span><span class="n">from_node</span><span class="p">,</span> <span class="n">to_node</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">offspring1</span><span class="p">,</span> <span class="n">offspring2</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">genetic_algorithm</span><span class="p">():</span>
    <span class="c1"># Initialize population
</span>    <span class="n">population</span> <span class="o">=</span> <span class="p">[</span><span class="nc">Chromosome</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">POPULATION_SIZE</span><span class="p">)]</span>

    <span class="n">best_fitness_history</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Genetic Algorithm main loop
</span>    <span class="k">for</span> <span class="n">generation</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">MAX_ITERATIONS</span><span class="p">):</span>
        <span class="c1"># Evaluate fitness for each chromosome
</span>        <span class="n">fitness_scores</span> <span class="o">=</span> <span class="p">[</span><span class="n">chromosome</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">check_average_propagation_cost</span><span class="p">()</span> <span class="k">for</span> <span class="n">chromosome</span> <span class="ow">in</span> <span class="n">population</span><span class="p">]</span>

        <span class="c1"># Track best fitness in this generation
</span>        <span class="n">best_fitness</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">fitness_scores</span><span class="p">)</span>
        <span class="n">best_fitness_history</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">best_fitness</span><span class="p">)</span>

        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Generation </span><span class="si">{</span><span class="n">generation</span><span class="si">}</span><span class="s">: Best Fitness = </span><span class="si">{</span><span class="n">best_fitness</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

        <span class="c1"># Select top 20% chromosomes for reproduction
</span>        <span class="n">sorted_population</span> <span class="o">=</span> <span class="nf">sorted</span><span class="p">(</span><span class="nf">zip</span><span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="n">fitness_scores</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">top_population</span> <span class="o">=</span> <span class="p">[</span><span class="n">chrom</span> <span class="k">for</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">sorted_population</span><span class="p">[:</span><span class="n">POPULATION_SIZE</span><span class="o">//</span><span class="mi">5</span><span class="p">]]</span>

        <span class="c1"># Create new population through crossover and mutation
</span>        <span class="n">new_population</span> <span class="o">=</span> <span class="n">top_population</span><span class="p">.</span><span class="nf">copy</span><span class="p">()</span>

        <span class="k">while</span> <span class="nf">len</span><span class="p">(</span><span class="n">new_population</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">POPULATION_SIZE</span><span class="p">:</span>
            <span class="c1"># Select parents for crossover
</span>            <span class="n">parent1</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">choice</span><span class="p">(</span><span class="n">top_population</span><span class="p">)</span>
            <span class="n">parent2</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">choice</span><span class="p">(</span><span class="n">top_population</span><span class="p">)</span>

            <span class="c1"># Perform crossover
</span>            <span class="n">offspring</span> <span class="o">=</span> <span class="n">parent1</span><span class="p">.</span><span class="nf">crossover</span><span class="p">(</span><span class="n">parent2</span><span class="p">)</span>

            <span class="c1"># Optional mutation
</span>            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">offspring</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">random</span><span class="p">.</span><span class="nf">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.8</span><span class="p">:</span>  <span class="c1"># 30% mutation rate
</span>                    <span class="n">child</span><span class="p">.</span><span class="nf">mutate</span><span class="p">()</span>

            <span class="n">new_population</span><span class="p">.</span><span class="nf">extend</span><span class="p">(</span><span class="n">offspring</span><span class="p">)</span>

        <span class="c1"># Truncate population to original size
</span>        <span class="n">population</span> <span class="o">=</span> <span class="n">new_population</span><span class="p">[:</span><span class="n">POPULATION_SIZE</span><span class="p">]</span>

    <span class="c1"># Return the best chromosome
</span>    <span class="n">best_chromosome</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">check_average_propagation_cost</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">best_chromosome</span>
</code></pre></div></div> <p>I tried with starting out with a fully-connected graph and removing edges, but it did not work out as good as this implementation (not sure why).</p> <p>The next (and final) part of the broadcast challenge is to make it more efficient. For this, we just need to batch out our messages; instead of sending one message at a time, we send <code class="language-plaintext highlighter-rouge">n</code> messages at a time. The message sending can work on a ticker, where we send deltas of messages every 100ms.</p> <h2 id="conclusion">Conclusion</h2> <p>This challenge was a lot of fun; esp. the genetic algorithm part. I had a lot of fun implementing it. The final part of the challenge was to batch out messages, which I did not include along with code for the last part in this tutorial for brevity. I will leave that as an exercise for the reader. The next challenges are counter-based challenges, and I plan to do them in go, like the way the engineers at fly.io intended. The code for this part can be found <a href="https://github.com/sandeshbhusal/gossip-glomers" rel="external nofollow noopener" target="_blank">here</a>.</p> </div> </article> </div> </div> <footer class="sticky-bottom mt-5" role="contentinfo"> <div class="container"> © Copyright 2025 Sandesh Bhusal. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?70d799092f862ad98c7876aa47712e20"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>