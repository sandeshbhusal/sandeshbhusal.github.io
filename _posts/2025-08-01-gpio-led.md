---
layout: post
title: "Baremetal on the RP2040"
date: 2025-08-01
published: false
toc:
  sidebar: right
description: "Writing code for rp2040 without by hand-rolling my own HAL for GPIO and UART and techniques to debug code using SWD and picoprobe"
tags:
- embedded
---

One of my earliest pieces of hardware code I wrote was for a [high-altitude balloon payload](https://github.com/sandeshbhusal/hab/) when I was a freshman (1st year student) in school. The mission was to write software for an Arduino board, which had a on-board MPU to analyze an algorithm for GPS-less location tracking. The board had a GPS peripheral on-board. There were two teams - one writing code for the GPS and another one for the MPU and we were working on two Arduino boards at the same time. When the time arrived to merge the codebases, we realized that the on-board RAM would not have space for the compiled code, let alone storing data (the board also had a GSM module to send data through cellular networks). Disappointed, we axed some code and hastily flashed the image to the Arduino. The HAB was scheduled to be launched through Mexico but due to logistic difficulties, it could not be executed in time, but the work was there nevertheless.

Now that I work on writing software for hardware as a full-time job, I sometimes think back to that time, and wonder how I would approach that problem if it was posed now. That also brings back the memories of the very first Arduino program:

```c
void setup() {
  pinMode(LED_BUILTIN, OUTPUT);
}

void loop() {
  digitalWrite(LED_BUILTIN, HIGH);   // turn the LED on (HIGH is the voltage level)
  delay(1000);                       // wait for a second
  digitalWrite(LED_BUILTIN, LOW);    // turn the LED off by making the voltage LOW
  delay(1000);                       // wait for a second
}
```

At the time when I wrote this code, I had no understanding of how electronics worked -- I do not feel like I still understand the vast majority of electronics, but I feel like I've certainly come a long way. Now I know what GPIOs are, what a microcontroller is, and how it differs from a Microprocessor, the different types of ARM products, yada yada.

So in this post, I will try to chronicle my journey of executing the same goal - writing `blinky`, i.e. a program that blinks a LED on a board. The challenge will be to execute it end-to-end relying on as little external code as possible - the baremetal way.

## Setup

I have a couple of Rasperry Pi Picos lying around, and I decided to work with them for this purpose. The rp2040 is a really [well documented](https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf) MCU, with a lot of support for external peripherals, GPIO, etc. For anyone beginning with firmware development on baremetal, I feel like this is the perfect second point (after STM32), because of a tricky boot situation this chip has. But that's a given -- even in real world, we rarely get to work with straightforward systems, that go like "do X then Y happens". It's always more like "do X then depending on Z either Y happens or something else". I am alluding, of course, to the convoluted boot process of the rp2040. But at least it's well-documented in the datasheet compared to the STM32 lol.

RP2040 has a weird boot process compared to the STM32 board. I had to spend quite a bit of time fiddling with the raw register addresses and boot process to identify what I should write and where, and in what specific order in order to make it work. Here are some interesting facts:

- The rp2040 has a multi-stage boot configuration. That means, unlike the stm32f4xx, whose boot config depends on the initial state of GPIO0, GPIO1 pins, the rp2040 initiates boot from a Bootrom, effectively located at `0x00000000`. The bootrom contains the first stage bootloader which initializes clocks, and just enough peripherals (foreshadowing) to determine where to boot from next.

- At boot0 (first stage), depending on the `BOOTSEL` pin, the rp2040 either presents itself as a USB mass storage device, or tries to boot through flash. If the `BOOTSEL` button is pressed when the power is on, it presents itself as a USB mass storage device where you can plop your `uf2` files (which is convenient -- and annoying at the same time! More on this later). If the pin is not active for `BOOTSEL`, rp2040 tries to boot through the flash.

- The flash is located at `0x10000000`. Here is another hurdle. rp2040 expects a 256-byte block of data at the flash start which is effectively the boot1 (second-stage) bootloader. This is where our programming effectively comes into play for the first time. As stm32, the first word is the stack pointer (very very important - foreshadowing), and the second word is the address of the reset handler. 

But the fun doesn't begin here! Remember the 256 byte block? Well, it should be _exactly_ 256 bytes. Including a CRC32 checksum at the end, of 4 byte length. Which means your boot1 bootloader can only be 252 bytes (which is OK), but the convoluated part is that the checksum of the first 252 bytes must match the last 4 bytes. This is how the firmware integrity is validated. If this is not valid, then, well, IDK what happens.

True to the nature of a CS person, I started off without knowing all this, and tried to "vibe code" a boot1 bootloader, like all the cool kids are doing these days. What I can summarize from my experience is that Google Gemini Pro is not only un-helpful, but downright misleading at this task. It hallucinates about adding random offsets at random places. Along with this, it starts to give you accurate information only after you give it accurate information, like "Shouldn't the stack pointer be set up first?" -> "Ah yes! Excellent! You are right, the SP should point to ...". I also hated every moment of psycophantic personality it adopts by trying to give you "positive reinforcement".

When vibe coding did not work out I returned to my roots of - well - reading the datasheet. The rp2040 datasheet is one of the most beautifully written pieces of datasheets out there (looking at you rockchip and stm). It precisely outlines all this information and more, although in different sections. By page 100, I was ready to write some code.

> How do you write code for a microcontroller?

Well, like you write .. normal code, right?
right?

Well yes and no. The code can be written the same way - except, you don't have a stdlib, and one of the challenges I set for myself was _absolutely not using the pico stdlib_ which meant I had to hand-roll my own firmware sdk from scratch. This looked like an adventure I was ready to tackle, considering the type of work I do professionally.

When you don't have stdlib, you don't have boot1 stage. When you don't have that - you can't verify if you init your board the right way or not. That means - well - you have to figure out a way to say that you have flashed your image the right way and it works too. So how do we do that? Well with a debug setup.

### Debuggers, RP2040 Debugprobe, and SWD


